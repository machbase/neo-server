//go:generate go run fx_generate.go

package tql

// Code generated by go generate; DO NOT EDIT.

import (
	"math"

	"github.com/machbase/neo-server/mods/codec/opts"
	"github.com/machbase/neo-server/mods/expression"
	"github.com/machbase/neo-server/mods/nums"
)

func NewNode(task *Task) *Node {
	x := &Node{task: task}
	x.functions = map[string]expression.Function{
		// context
		"context":     x.gen_context,
		"key":         x.gen_key,
		"value":       x.gen_value,
		"param":       x.gen_param,
		"payload":     x.gen_payload,
		"escapeParam": x.gen_escapeParam,
		"ARGS":        x.gen_ARGS,
		// math
		"abs":       mathWrap("abs", math.Abs),
		"acos":      mathWrap("acos", math.Acos),
		"acosh":     mathWrap("acosh", math.Acosh),
		"asin":      mathWrap("asin", math.Asin),
		"asinh":     mathWrap("asinh", math.Asinh),
		"atan":      mathWrap("atan", math.Atan),
		"atanh":     mathWrap("atanh", math.Atanh),
		"ceil":      mathWrap("ceil", math.Ceil),
		"cos":       mathWrap("cos", math.Cos),
		"cosh":      mathWrap("cosh", math.Cosh),
		"exp":       mathWrap("exp", math.Exp),
		"exp2":      mathWrap("exp2", math.Exp2),
		"floor":     mathWrap("floor", math.Floor),
		"log":       mathWrap("log", math.Log),
		"log10":     mathWrap("log10", math.Log10),
		"log2":      mathWrap("log2", math.Log2),
		"mod":       mathWrap2("mod", math.Mod),
		"pow":       mathWrap2("pow", math.Pow),
		"pow10":     mathWrapi("pow10", math.Pow10),
		"remainder": mathWrap2("remainder", math.Remainder),
		"round":     mathWrap("round", math.Round),
		"sin":       mathWrap("sin", math.Sin),
		"sinh":      mathWrap("sinh", math.Sinh),
		"sqrt":      mathWrap("sqrt", math.Sqrt),
		"tan":       mathWrap("tan", math.Tan),
		"tanh":      mathWrap("tanh", math.Tanh),
		"trunc":     mathWrap("trunc", math.Trunc),
		// nums
		"count":           nums.Count,
		"len":             nums.Len,
		"element":         nums.Element,
		"linspace":        x.gen_linspace,
		"linspace50":      x.gen_linspace50,
		"meshgrid":        x.gen_meshgrid,
		"latlng":          x.gen_latlng,
		"geoPoint":        x.gen_geoPoint,
		"geoMultiPoint":   x.gen_geoMultiPoint,
		"geoCircle":       x.gen_geoCircle,
		"geoPolygon":      x.gen_geoPolygon,
		"geoLineString":   x.gen_geoLineString,
		"geoPointMarker":  x.gen_geoPointMarker,
		"geoCircleMarker": x.gen_geoCircleMarker,
		// maps.time
		"period":         x.gen_period,
		"nullValue":      x.gen_nullValue,
		"time":           x.gen_time,
		"parseTime":      x.gen_parseTime,
		"timeAdd":        x.gen_timeAdd,
		"roundTime":      x.gen_roundTime,
		"range":          x.gen_range,
		"sqlTimeformat":  x.gen_sqlTimeformat,
		"ansiTimeformat": x.gen_ansiTimeformat,
		// maps.monad
		"TAKE":          x.gen_TAKE,
		"DROP":          x.gen_DROP,
		"FILTER":        x.gen_FILTER,
		"FLATTEN":       x.gen_FLATTEN,
		"GROUPBYKEY":    x.gen_GROUPBYKEY,
		"POPKEY":        x.gen_POPKEY,
		"PUSHKEY":       x.gen_PUSHKEY,
		"MAPKEY":        x.gen_MAPKEY,
		"POPVALUE":      x.gen_POPVALUE,
		"PUSHVALUE":     x.gen_PUSHVALUE,
		"MAPVALUE":      x.gen_MAPVALUE,
		"MAP_MOVAVG":    x.gen_MAP_MOVAVG,
		"MAP_DIFF":      x.gen_MAP_DIFF,
		"MAP_ABSDIFF":   x.gen_MAP_ABSDIFF,
		"MAP_NONEGDIFF": x.gen_MAP_NONEGDIFF,
		"TRANSPOSE":     x.gen_TRANSPOSE,
		"fixed":         x.gen_fixed,
		"TIMEWINDOW":    x.gen_TIMEWINDOW,
		"SCRIPT":        x.gen_SCRIPT,
		"list":          x.gen_list,
		"dict":          x.gen_dict,
		"lazy":          x.gen_lazy,
		"glob":          x.gen_glob,
		"regexp":        x.gen_regexp,
		"doLog":         x.gen_doLog,
		"doHttp":        x.gen_doHttp,
		"do":            x.gen_do,
		"args":          x.gen_args,
		"WHEN":          x.gen_WHEN,
		"THROTTLE":      x.gen_THROTTLE,
		// maps.dbsrc
		"from":    x.gen_from,
		"limit":   x.gen_limit,
		"between": x.gen_between,
		"dump":    x.gen_dump,
		"QUERY":   x.gen_QUERY,
		"SQL":     x.gen_SQL,
		// maps.dbsink
		"table":  x.gen_table,
		"tag":    x.gen_tag,
		"INSERT": x.gen_INSERT,
		"APPEND": x.gen_APPEND,
		// maps.bridge
		"bridge":       x.gen_bridge,
		"BRIDGE_QUERY": x.gen_BRIDGE_QUERY,
		// maps.fourier
		"minHz": x.gen_minHz,
		"maxHz": x.gen_maxHz,
		"FFT":   x.gen_FFT,
		// maps.encoder
		"CSV":             x.gen_CSV,
		"JSON":            x.gen_JSON,
		"MARKDOWN":        x.gen_MARKDOWN,
		"HTML":            x.gen_HTML,
		"DISCARD":         x.gen_DISCARD,
		"CHART":           x.gen_CHART,
		"CHART_LINE":      x.gen_CHART_LINE,
		"CHART_SCATTER":   x.gen_CHART_SCATTER,
		"CHART_BAR":       x.gen_CHART_BAR,
		"CHART_LINE3D":    x.gen_CHART_LINE3D,
		"CHART_BAR3D":     x.gen_CHART_BAR3D,
		"CHART_SURFACE3D": x.gen_CHART_SURFACE3D,
		"CHART_SCATTER3D": x.gen_CHART_SCATTER3D,
		"GEOMAP":          x.gen_GEOMAP,
		// maps.bytes
		"separator": x.gen_separator,
		"trimspace": x.gen_trimspace,
		"file":      x.gen_file,
		"charset":   x.gen_charset,
		"STRING":    x.gen_STRING,
		"BYTES":     x.gen_BYTES,
		// maps.csv
		"col":                x.gen_col,
		"field":              x.gen_field,
		"datetimeType":       x.gen_datetimeType,
		"stringType":         x.gen_stringType,
		"doubleType":         x.gen_doubleType,
		"simplex":            x.gen_simplex,
		"random":             x.gen_random,
		"parseFloat":         x.gen_parseFloat,
		"parseBool":          x.gen_parseBool,
		"strTrimSpace":       x.gen_strTrimSpace,
		"strTrimPrefix":      x.gen_strTrimPrefix,
		"strTrimSuffix":      x.gen_strTrimSuffix,
		"strReplaceAll":      x.gen_strReplaceAll,
		"strReplace":         x.gen_strReplace,
		"strHasPrefix":       x.gen_strHasPrefix,
		"strHasSuffix":       x.gen_strHasSuffix,
		"strSprintf":         x.gen_strSprintf,
		"strSub":             x.gen_strSub,
		"strToUpper":         x.gen_strToUpper,
		"strToLower":         x.gen_strToLower,
		"freq":               x.gen_freq,
		"oscillator":         x.gen_oscillator,
		"sphere":             x.gen_sphere,
		"json":               x.gen_json,
		"csv":                x.gen_csv,
		"FAKE":               x.gen_FAKE,
		"GROUP":              x.gen_GROUP,
		"by":                 x.gen_by,
		"first":              x.gen_first,
		"last":               x.gen_last,
		"min":                x.gen_min,
		"max":                x.gen_max,
		"sum":                x.gen_sum,
		"mean":               x.gen_mean,
		"median":             x.gen_median,
		"medianInterpolated": x.gen_medianInterpolated,
		"stddev":             x.gen_stddev,
		"stderr":             x.gen_stderr,
		"entropy":            x.gen_entropy,
		"mode":               x.gen_mode,
		"avg":                x.gen_avg,
		"rss":                x.gen_rss,
		"rms":                x.gen_rms,
		// maps.input
		"INPUT": x.gen_INPUT,
		// maps.output
		"OUTPUT": x.gen_OUTPUT,
		// aliases
		"markArea":  x.fmMarkArea,
		"markXAxis": x.gen_markLineXAxisCoord,
		"markYAxis": x.gen_markLineYAxisCoord,
		"tz":        x.gen_tz,
		"sep":       x.gen_sep,
		// codec.opts
		"assetHost":           x.gen_assetHost,
		"autoRotate":          x.gen_autoRotate,
		"boxDrawBorder":       x.gen_boxDrawBorder,
		"boxSeparateColumns":  x.gen_boxSeparateColumns,
		"boxStyle":            x.gen_boxStyle,
		"brief":               x.gen_brief,
		"briefCount":          x.gen_briefCount,
		"charsetEncoding":     x.gen_charsetEncoding,
		"chartCDN":            x.gen_chartCDN,
		"chartDispatchAction": x.gen_chartDispatchAction,
		"chartId":             x.gen_chartId,
		"chartJSCode":         x.gen_chartJSCode,
		"chartJson":           x.gen_chartJson,
		"chartOption":         x.gen_chartOption,
		"columnTypes":         x.gen_columnTypes,
		"columns":             x.gen_columns,
		"dataZoom":            x.gen_dataZoom,
		"delimiter":           x.gen_delimiter,
		"geoMapJson":          x.gen_geoMapJson,
		"globalOptions":       x.gen_globalOptions,
		"gridSize":            x.gen_gridSize,
		"header":              x.gen_header,
		"heading":             x.gen_heading,
		"html":                x.gen_html,
		"icon":                x.gen_icon,
		"initialLocation":     x.gen_initialLocation,
		"inputStream":         x.gen_inputStream,
		"lineWidth":           x.gen_lineWidth,
		"logger":              x.gen_logger,
		"mapId":               x.gen_mapId,
		"markAreaNameCoord":   x.gen_markAreaNameCoord,
		"markLineXAxisCoord":  x.gen_markLineXAxisCoord,
		"markLineYAxisCoord":  x.gen_markLineYAxisCoord,
		"marker":              x.gen_marker,
		"opacity":             x.gen_opacity,
		"outputStream":        x.gen_outputStream,
		"plugins":             x.gen_plugins,
		"pointStyle":          x.gen_pointStyle,
		"precision":           x.gen_precision,
		"rownum":              x.gen_rownum,
		"seriesLabels":        x.gen_seriesLabels,
		"seriesOptions":       x.gen_seriesOptions,
		"showGrid":            x.gen_showGrid,
		"size":                x.gen_size,
		"substituteNull":      x.gen_substituteNull,
		"subtitle":            x.gen_subtitle,
		"tableName":           x.gen_tableName,
		"theme":               x.gen_theme,
		"tileGrayscale":       x.gen_tileGrayscale,
		"tileOption":          x.gen_tileOption,
		"tileTemplate":        x.gen_tileTemplate,
		"timeLocation":        x.gen_timeLocation,
		"timeformat":          x.gen_timeformat,
		"title":               x.gen_title,
		"toolboxDataView":     x.gen_toolboxDataView,
		"toolboxDataZoom":     x.gen_toolboxDataZoom,
		"toolboxSaveAsImage":  x.gen_toolboxSaveAsImage,
		"transcoder":          x.gen_transcoder,
		"transpose":           x.gen_transpose,
		"visualMap":           x.gen_visualMap,
		"visualMapColor":      x.gen_visualMapColor,
		"xAxis":               x.gen_xAxis,
		"yAxis":               x.gen_yAxis,
		"zAxis":               x.gen_zAxis,
	}
	return x
}

// gen_context
//
// syntax: context()
func (x *Node) gen_context(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, ErrInvalidNumOfArgs("context", 0, len(args))
	}
	ret := x.GetContext()
	return ret, nil
}

// gen_key
//
// syntax: key()
func (x *Node) gen_key(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, ErrInvalidNumOfArgs("key", 0, len(args))
	}
	ret := x.GetRecordKey()
	return ret, nil
}

// gen_value
//
// syntax: value(...interface {})
func (x *Node) gen_value(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "value", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.GetRecordValue(p0...)
}

// gen_param
//
// syntax: param(string)
func (x *Node) gen_param(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("param", 1, len(args))
	}
	p0, err := convString(args, 0, "param", "string")
	if err != nil {
		return nil, err
	}
	ret := x.GetRequestParam(p0)
	return ret, nil
}

// gen_payload
//
// syntax: payload()
func (x *Node) gen_payload(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, ErrInvalidNumOfArgs("payload", 0, len(args))
	}
	ret := x.GetRequestPayload()
	return ret, nil
}

// gen_escapeParam
//
// syntax: escapeParam(string)
func (x *Node) gen_escapeParam(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("escapeParam", 1, len(args))
	}
	p0, err := convString(args, 0, "escapeParam", "string")
	if err != nil {
		return nil, err
	}
	ret := x.EscapeParam(p0)
	return ret, nil
}

// gen_ARGS
//
// syntax: ARGS()
func (x *Node) gen_ARGS(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, ErrInvalidNumOfArgs("ARGS", 0, len(args))
	}
	return x.fmArgs()
}

// gen_linspace
//
// syntax: linspace(float64, float64, int)
func (x *Node) gen_linspace(args ...any) (any, error) {
	if len(args) != 3 {
		return nil, ErrInvalidNumOfArgs("linspace", 3, len(args))
	}
	p0, err := convFloat64(args, 0, "linspace", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "linspace", "float64")
	if err != nil {
		return nil, err
	}
	p2, err := convInt(args, 2, "linspace", "int")
	if err != nil {
		return nil, err
	}
	ret := x.fmLinspace(p0, p1, p2)
	return ret, nil
}

// gen_linspace50
//
// syntax: linspace50(float64, float64)
func (x *Node) gen_linspace50(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("linspace50", 2, len(args))
	}
	p0, err := convFloat64(args, 0, "linspace50", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "linspace50", "float64")
	if err != nil {
		return nil, err
	}
	ret := x.fmLinspace50(p0, p1)
	return ret, nil
}

// gen_meshgrid
//
// syntax: meshgrid(, )
func (x *Node) gen_meshgrid(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("meshgrid", 2, len(args))
	}
	p0, err := convAny(args, 0, "meshgrid", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "meshgrid", "interface {}")
	if err != nil {
		return nil, err
	}
	ret := x.fmMeshgrid(p0, p1)
	return ret, nil
}

// gen_latlng
//
// syntax: latlng(float64, float64)
func (x *Node) gen_latlng(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("latlng", 2, len(args))
	}
	p0, err := convFloat64(args, 0, "latlng", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "latlng", "float64")
	if err != nil {
		return nil, err
	}
	ret := nums.NewLatLng(p0, p1)
	return ret, nil
}

// gen_geoPoint
//
// syntax: geoPoint(, ...map[string]interface {})
func (x *Node) gen_geoPoint(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("geoPoint", 1, len(args))
	}
	p0, err := convLatLng(args, 0, "geoPoint", "*nums.LatLng")
	if err != nil {
		return nil, err
	}
	p1 := []map[string]interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convDictionary(args, n, "geoPoint", "...map[string]interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := nums.NewGeoPoint(p0, p1...)
	return ret, nil
}

// gen_geoMultiPoint
//
// syntax: geoMultiPoint([]interface {}, ...map[string]interface {})
func (x *Node) gen_geoMultiPoint(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("geoMultiPoint", 1, len(args))
	}
	p0, ok := args[0].([]interface{})
	if !ok {
		return nil, ErrWrongTypeOfArgs("geoMultiPoint", 0, "[]interface {}", args[0])
	}
	p1 := []map[string]interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convDictionary(args, n, "geoMultiPoint", "...map[string]interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := nums.NewGeoMultiPoint(p0, p1...)
	return ret, nil
}

// gen_geoCircle
//
// syntax: geoCircle(, float64, ...map[string]interface {})
func (x *Node) gen_geoCircle(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("geoCircle", 2, len(args))
	}
	p0, err := convLatLng(args, 0, "geoCircle", "*nums.LatLng")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "geoCircle", "float64")
	if err != nil {
		return nil, err
	}
	p2 := []map[string]interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convDictionary(args, n, "geoCircle", "...map[string]interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := nums.NewGeoCircle(p0, p1, p2...)
	return ret, nil
}

// gen_geoPolygon
//
// syntax: geoPolygon([]interface {}, ...map[string]interface {})
func (x *Node) gen_geoPolygon(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("geoPolygon", 1, len(args))
	}
	p0, ok := args[0].([]interface{})
	if !ok {
		return nil, ErrWrongTypeOfArgs("geoPolygon", 0, "[]interface {}", args[0])
	}
	p1 := []map[string]interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convDictionary(args, n, "geoPolygon", "...map[string]interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := nums.NewGeoPolygon(p0, p1...)
	return ret, nil
}

// gen_geoLineString
//
// syntax: geoLineString([]interface {}, ...map[string]interface {})
func (x *Node) gen_geoLineString(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("geoLineString", 1, len(args))
	}
	p0, ok := args[0].([]interface{})
	if !ok {
		return nil, ErrWrongTypeOfArgs("geoLineString", 0, "[]interface {}", args[0])
	}
	p1 := []map[string]interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convDictionary(args, n, "geoLineString", "...map[string]interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := nums.NewGeoLineString(p0, p1...)
	return ret, nil
}

// gen_geoPointMarker
//
// syntax: geoPointMarker(, ...map[string]interface {})
func (x *Node) gen_geoPointMarker(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("geoPointMarker", 1, len(args))
	}
	p0, err := convLatLng(args, 0, "geoPointMarker", "*nums.LatLng")
	if err != nil {
		return nil, err
	}
	p1 := []map[string]interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convDictionary(args, n, "geoPointMarker", "...map[string]interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := nums.NewGeoPointMarker(p0, p1...)
	return ret, nil
}

// gen_geoCircleMarker
//
// syntax: geoCircleMarker(, float64, ...map[string]interface {})
func (x *Node) gen_geoCircleMarker(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("geoCircleMarker", 2, len(args))
	}
	p0, err := convLatLng(args, 0, "geoCircleMarker", "*nums.LatLng")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "geoCircleMarker", "float64")
	if err != nil {
		return nil, err
	}
	p2 := []map[string]interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convDictionary(args, n, "geoCircleMarker", "...map[string]interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := nums.NewGeoCircleMarker(p0, p1, p2...)
	return ret, nil
}

// gen_period
//
// syntax: period()
func (x *Node) gen_period(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("period", 1, len(args))
	}
	p0, err := convAny(args, 0, "period", "interface {}")
	if err != nil {
		return nil, err
	}
	return x.fmPeriod(p0)
}

// gen_nullValue
//
// syntax: nullValue()
func (x *Node) gen_nullValue(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("nullValue", 1, len(args))
	}
	p0, err := convAny(args, 0, "nullValue", "interface {}")
	if err != nil {
		return nil, err
	}
	ret := x.fmNullValue(p0)
	return ret, nil
}

// gen_time
//
// syntax: time()
func (x *Node) gen_time(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("time", 1, len(args))
	}
	p0, err := convAny(args, 0, "time", "interface {}")
	if err != nil {
		return nil, err
	}
	return x.fmTime(p0)
}

// gen_parseTime
//
// syntax: parseTime(string, , )
func (x *Node) gen_parseTime(args ...any) (any, error) {
	if len(args) != 3 {
		return nil, ErrInvalidNumOfArgs("parseTime", 3, len(args))
	}
	p0, err := convString(args, 0, "parseTime", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "parseTime", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := convTimeLocation(args, 2, "parseTime", "*time.Location")
	if err != nil {
		return nil, err
	}
	return x.fmParseTime(p0, p1, p2)
}

// gen_timeAdd
//
// syntax: timeAdd(, )
func (x *Node) gen_timeAdd(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("timeAdd", 2, len(args))
	}
	p0, err := convAny(args, 0, "timeAdd", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "timeAdd", "interface {}")
	if err != nil {
		return nil, err
	}
	return x.fmTimeAdd(p0, p1)
}

// gen_roundTime
//
// syntax: roundTime(, )
func (x *Node) gen_roundTime(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("roundTime", 2, len(args))
	}
	p0, err := convAny(args, 0, "roundTime", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "roundTime", "interface {}")
	if err != nil {
		return nil, err
	}
	return x.fmRoundTime(p0, p1)
}

// gen_range
//
// syntax: range(, , ...interface {})
func (x *Node) gen_range(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("range", 2, len(args))
	}
	p0, err := convAny(args, 0, "range", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "range", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convAny(args, n, "range", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmTimeRange(p0, p1, p2...)
}

// gen_sqlTimeformat
//
// syntax: sqlTimeformat(string)
func (x *Node) gen_sqlTimeformat(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("sqlTimeformat", 1, len(args))
	}
	p0, err := convString(args, 0, "sqlTimeformat", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmSqlTimeformat(p0)
	return ret, nil
}

// gen_ansiTimeformat
//
// syntax: ansiTimeformat(string)
func (x *Node) gen_ansiTimeformat(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("ansiTimeformat", 1, len(args))
	}
	p0, err := convString(args, 0, "ansiTimeformat", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmAnsiTimeformat(p0)
	return ret, nil
}

// gen_TAKE
//
// syntax: TAKE(...int)
func (x *Node) gen_TAKE(args ...any) (any, error) {
	p0 := []int{}
	for n := 0; n < len(args); n++ {
		argv, err := convInt(args, n, "TAKE", "...int")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmTake(p0...)
}

// gen_DROP
//
// syntax: DROP(...int)
func (x *Node) gen_DROP(args ...any) (any, error) {
	p0 := []int{}
	for n := 0; n < len(args); n++ {
		argv, err := convInt(args, n, "DROP", "...int")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmDrop(p0...)
}

// gen_FILTER
//
// syntax: FILTER(bool)
func (x *Node) gen_FILTER(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("FILTER", 1, len(args))
	}
	p0, err := convBool(args, 0, "FILTER", "bool")
	if err != nil {
		return nil, err
	}
	ret := x.fmFilter(p0)
	return ret, nil
}

// gen_FLATTEN
//
// syntax: FLATTEN()
func (x *Node) gen_FLATTEN(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, ErrInvalidNumOfArgs("FLATTEN", 0, len(args))
	}
	ret := x.fmFlatten()
	return ret, nil
}

// gen_GROUPBYKEY
//
// syntax: GROUPBYKEY(...interface {})
func (x *Node) gen_GROUPBYKEY(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "GROUPBYKEY", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := x.fmGroupByKey(p0...)
	return ret, nil
}

// gen_POPKEY
//
// syntax: POPKEY(...int)
func (x *Node) gen_POPKEY(args ...any) (any, error) {
	p0 := []int{}
	for n := 0; n < len(args); n++ {
		argv, err := convInt(args, n, "POPKEY", "...int")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmPopKey(p0...)
}

// gen_PUSHKEY
//
// syntax: PUSHKEY()
func (x *Node) gen_PUSHKEY(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("PUSHKEY", 1, len(args))
	}
	p0, err := convAny(args, 0, "PUSHKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	return x.fmPushKey(p0)
}

// gen_MAPKEY
//
// syntax: MAPKEY()
func (x *Node) gen_MAPKEY(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("MAPKEY", 1, len(args))
	}
	p0, err := convAny(args, 0, "MAPKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	return x.fmMapKey(p0)
}

// gen_POPVALUE
//
// syntax: POPVALUE(...int)
func (x *Node) gen_POPVALUE(args ...any) (any, error) {
	p0 := []int{}
	for n := 0; n < len(args); n++ {
		argv, err := convInt(args, n, "POPVALUE", "...int")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmPopValue(p0...)
}

// gen_PUSHVALUE
//
// syntax: PUSHVALUE(int, , ...interface {})
func (x *Node) gen_PUSHVALUE(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("PUSHVALUE", 2, len(args))
	}
	p0, err := convInt(args, 0, "PUSHVALUE", "int")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "PUSHVALUE", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convAny(args, n, "PUSHVALUE", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmPushValue(p0, p1, p2...)
}

// gen_MAPVALUE
//
// syntax: MAPVALUE(int, , ...interface {})
func (x *Node) gen_MAPVALUE(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("MAPVALUE", 2, len(args))
	}
	p0, err := convInt(args, 0, "MAPVALUE", "int")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "MAPVALUE", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convAny(args, n, "MAPVALUE", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmMapValue(p0, p1, p2...)
}

// gen_MAP_MOVAVG
//
// syntax: MAP_MOVAVG(int, , int, ...interface {})
func (x *Node) gen_MAP_MOVAVG(args ...any) (any, error) {
	if len(args) < 3 {
		return nil, ErrInvalidNumOfArgs("MAP_MOVAVG", 3, len(args))
	}
	p0, err := convInt(args, 0, "MAP_MOVAVG", "int")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "MAP_MOVAVG", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := convInt(args, 2, "MAP_MOVAVG", "int")
	if err != nil {
		return nil, err
	}
	p3 := []interface{}{}
	for n := 3; n < len(args); n++ {
		argv, err := convAny(args, n, "MAP_MOVAVG", "...interface {}")
		if err != nil {
			return nil, err
		}
		p3 = append(p3, argv)
	}
	return x.fmMovAvg(p0, p1, p2, p3...)
}

// gen_MAP_DIFF
//
// syntax: MAP_DIFF(int, , ...interface {})
func (x *Node) gen_MAP_DIFF(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("MAP_DIFF", 2, len(args))
	}
	p0, err := convInt(args, 0, "MAP_DIFF", "int")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "MAP_DIFF", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convAny(args, n, "MAP_DIFF", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmDiff(p0, p1, p2...)
}

// gen_MAP_ABSDIFF
//
// syntax: MAP_ABSDIFF(int, , ...interface {})
func (x *Node) gen_MAP_ABSDIFF(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("MAP_ABSDIFF", 2, len(args))
	}
	p0, err := convInt(args, 0, "MAP_ABSDIFF", "int")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "MAP_ABSDIFF", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convAny(args, n, "MAP_ABSDIFF", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmAbsDiff(p0, p1, p2...)
}

// gen_MAP_NONEGDIFF
//
// syntax: MAP_NONEGDIFF(int, , ...interface {})
func (x *Node) gen_MAP_NONEGDIFF(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("MAP_NONEGDIFF", 2, len(args))
	}
	p0, err := convInt(args, 0, "MAP_NONEGDIFF", "int")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "MAP_NONEGDIFF", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convAny(args, n, "MAP_NONEGDIFF", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmNonNegativeDiff(p0, p1, p2...)
}

// gen_TRANSPOSE
//
// syntax: TRANSPOSE(...interface {})
func (x *Node) gen_TRANSPOSE(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "TRANSPOSE", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmTranspose(p0...)
}

// gen_fixed
//
// syntax: fixed(...int)
func (x *Node) gen_fixed(args ...any) (any, error) {
	p0 := []int{}
	for n := 0; n < len(args); n++ {
		argv, err := convInt(args, n, "fixed", "...int")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := x.fmFixed(p0...)
	return ret, nil
}

// gen_TIMEWINDOW
//
// syntax: TIMEWINDOW(, , , ...interface {})
func (x *Node) gen_TIMEWINDOW(args ...any) (any, error) {
	if len(args) < 3 {
		return nil, ErrInvalidNumOfArgs("TIMEWINDOW", 3, len(args))
	}
	p0, err := convAny(args, 0, "TIMEWINDOW", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "TIMEWINDOW", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := convAny(args, 2, "TIMEWINDOW", "interface {}")
	if err != nil {
		return nil, err
	}
	p3 := []interface{}{}
	for n := 3; n < len(args); n++ {
		argv, err := convAny(args, n, "TIMEWINDOW", "...interface {}")
		if err != nil {
			return nil, err
		}
		p3 = append(p3, argv)
	}
	ret := x.fmTimeWindow(p0, p1, p2, p3...)
	return ret, nil
}

// gen_SCRIPT
//
// syntax: SCRIPT(...interface {})
func (x *Node) gen_SCRIPT(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "SCRIPT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmScript(p0...)
}

// gen_list
//
// syntax: list(...interface {})
func (x *Node) gen_list(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "list", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := x.fmList(p0...)
	return ret, nil
}

// gen_dict
//
// syntax: dict(...interface {})
func (x *Node) gen_dict(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "dict", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmDictionary(p0...)
}

// gen_lazy
//
// syntax: lazy(bool)
func (x *Node) gen_lazy(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("lazy", 1, len(args))
	}
	p0, err := convBool(args, 0, "lazy", "bool")
	if err != nil {
		return nil, err
	}
	ret := x.fmLazy(p0)
	return ret, nil
}

// gen_glob
//
// syntax: glob(string, string)
func (x *Node) gen_glob(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("glob", 2, len(args))
	}
	p0, err := convString(args, 0, "glob", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "glob", "string")
	if err != nil {
		return nil, err
	}
	return x.fmGlob(p0, p1)
}

// gen_regexp
//
// syntax: regexp(string, string)
func (x *Node) gen_regexp(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("regexp", 2, len(args))
	}
	p0, err := convString(args, 0, "regexp", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "regexp", "string")
	if err != nil {
		return nil, err
	}
	return x.fmRegexp(p0, p1)
}

// gen_doLog
//
// syntax: doLog(...interface {})
func (x *Node) gen_doLog(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "doLog", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := x.fmDoLog(p0...)
	return ret, nil
}

// gen_doHttp
//
// syntax: doHttp(string, string, , ...string)
func (x *Node) gen_doHttp(args ...any) (any, error) {
	if len(args) < 3 {
		return nil, ErrInvalidNumOfArgs("doHttp", 3, len(args))
	}
	p0, err := convString(args, 0, "doHttp", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "doHttp", "string")
	if err != nil {
		return nil, err
	}
	p2, err := convAny(args, 2, "doHttp", "interface {}")
	if err != nil {
		return nil, err
	}
	p3 := []string{}
	for n := 3; n < len(args); n++ {
		argv, err := convString(args, n, "doHttp", "...string")
		if err != nil {
			return nil, err
		}
		p3 = append(p3, argv)
	}
	ret := x.fmDoHttp(p0, p1, p2, p3...)
	return ret, nil
}

// gen_do
//
// syntax: do(...interface {})
func (x *Node) gen_do(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "do", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmDo(p0...)
}

// gen_args
//
// syntax: args(...interface {})
func (x *Node) gen_args(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "args", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmArgsParam(p0...)
}

// gen_WHEN
//
// syntax: WHEN(bool, )
func (x *Node) gen_WHEN(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("WHEN", 2, len(args))
	}
	p0, err := convBool(args, 0, "WHEN", "bool")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "WHEN", "interface {}")
	if err != nil {
		return nil, err
	}
	ret := x.fmWhen(p0, p1)
	return ret, nil
}

// gen_THROTTLE
//
// syntax: THROTTLE(float64)
func (x *Node) gen_THROTTLE(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("THROTTLE", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "THROTTLE", "float64")
	if err != nil {
		return nil, err
	}
	ret := x.fmThrottle(p0)
	return ret, nil
}

// gen_from
//
// syntax: from(string, string, ...string)
func (x *Node) gen_from(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("from", 2, len(args))
	}
	p0, err := convString(args, 0, "from", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "from", "string")
	if err != nil {
		return nil, err
	}
	p2 := []string{}
	for n := 2; n < len(args); n++ {
		argv, err := convString(args, n, "from", "...string")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := x.fmFrom(p0, p1, p2...)
	return ret, nil
}

// gen_limit
//
// syntax: limit(...int)
func (x *Node) gen_limit(args ...any) (any, error) {
	p0 := []int{}
	for n := 0; n < len(args); n++ {
		argv, err := convInt(args, n, "limit", "...int")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := x.fmLimit(p0...)
	return ret, nil
}

// gen_between
//
// syntax: between(, , ...interface {})
func (x *Node) gen_between(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("between", 2, len(args))
	}
	p0, err := convAny(args, 0, "between", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "between", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convAny(args, n, "between", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmBetween(p0, p1, p2...)
}

// gen_dump
//
// syntax: dump(...bool)
func (x *Node) gen_dump(args ...any) (any, error) {
	p0 := []bool{}
	for n := 0; n < len(args); n++ {
		argv, err := convBool(args, n, "dump", "...bool")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := x.fmDump(p0...)
	return ret, nil
}

// gen_QUERY
//
// syntax: QUERY(...interface {})
func (x *Node) gen_QUERY(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "QUERY", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmQuery(p0...)
}

// gen_SQL
//
// syntax: SQL(...interface {})
func (x *Node) gen_SQL(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "SQL", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmSql(p0...)
}

// gen_table
//
// syntax: table(string)
func (x *Node) gen_table(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("table", 1, len(args))
	}
	p0, err := convString(args, 0, "table", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmTable(p0)
	return ret, nil
}

// gen_tag
//
// syntax: tag(string, ...string)
func (x *Node) gen_tag(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("tag", 1, len(args))
	}
	p0, err := convString(args, 0, "tag", "string")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "tag", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmTag(p0, p1...)
	return ret, nil
}

// gen_INSERT
//
// syntax: INSERT(...interface {})
func (x *Node) gen_INSERT(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "INSERT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmInsert(p0...)
}

// gen_APPEND
//
// syntax: APPEND(...interface {})
func (x *Node) gen_APPEND(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "APPEND", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmAppend(p0...)
}

// gen_bridge
//
// syntax: bridge(string)
func (x *Node) gen_bridge(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("bridge", 1, len(args))
	}
	p0, err := convString(args, 0, "bridge", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmBridge(p0)
	return ret, nil
}

// gen_BRIDGE_QUERY
//
// syntax: BRIDGE_QUERY(string, string, ...interface {})
func (x *Node) gen_BRIDGE_QUERY(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("BRIDGE_QUERY", 2, len(args))
	}
	p0, err := convString(args, 0, "BRIDGE_QUERY", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "BRIDGE_QUERY", "string")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := convAny(args, n, "BRIDGE_QUERY", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmBridgeQuery(p0, p1, p2...)
}

// gen_minHz
//
// syntax: minHz(float64)
func (x *Node) gen_minHz(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("minHz", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "minHz", "float64")
	if err != nil {
		return nil, err
	}
	ret := x.fmMinHz(p0)
	return ret, nil
}

// gen_maxHz
//
// syntax: maxHz(float64)
func (x *Node) gen_maxHz(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("maxHz", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "maxHz", "float64")
	if err != nil {
		return nil, err
	}
	ret := x.fmMaxHz(p0)
	return ret, nil
}

// gen_FFT
//
// syntax: FFT(...interface {})
func (x *Node) gen_FFT(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "FFT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmFastFourierTransform(p0...)
}

// gen_CSV
//
// syntax: CSV(...interface {})
func (x *Node) gen_CSV(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CSV", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmCsv(p0...)
}

// gen_JSON
//
// syntax: JSON(...interface {})
func (x *Node) gen_JSON(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "JSON", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmJson(p0...)
}

// gen_MARKDOWN
//
// syntax: MARKDOWN(...interface {})
func (x *Node) gen_MARKDOWN(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "MARKDOWN", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmMarkdown(p0...)
}

// gen_HTML
//
// syntax: HTML(...interface {})
func (x *Node) gen_HTML(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "HTML", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmHtml(p0...)
}

// gen_DISCARD
//
// syntax: DISCARD(...interface {})
func (x *Node) gen_DISCARD(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "DISCARD", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmDiscard(p0...)
}

// gen_CHART
//
// syntax: CHART(...interface {})
func (x *Node) gen_CHART(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CHART", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmChart(p0...)
}

// gen_CHART_LINE
//
// syntax: CHART_LINE(...interface {})
func (x *Node) gen_CHART_LINE(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CHART_LINE", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmChartLine(p0...)
}

// gen_CHART_SCATTER
//
// syntax: CHART_SCATTER(...interface {})
func (x *Node) gen_CHART_SCATTER(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CHART_SCATTER", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmChartScatter(p0...)
}

// gen_CHART_BAR
//
// syntax: CHART_BAR(...interface {})
func (x *Node) gen_CHART_BAR(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CHART_BAR", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmChartBar(p0...)
}

// gen_CHART_LINE3D
//
// syntax: CHART_LINE3D(...interface {})
func (x *Node) gen_CHART_LINE3D(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CHART_LINE3D", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmChartLine3D(p0...)
}

// gen_CHART_BAR3D
//
// syntax: CHART_BAR3D(...interface {})
func (x *Node) gen_CHART_BAR3D(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CHART_BAR3D", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmChartBar3D(p0...)
}

// gen_CHART_SURFACE3D
//
// syntax: CHART_SURFACE3D(...interface {})
func (x *Node) gen_CHART_SURFACE3D(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CHART_SURFACE3D", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmChartSurface3D(p0...)
}

// gen_CHART_SCATTER3D
//
// syntax: CHART_SCATTER3D(...interface {})
func (x *Node) gen_CHART_SCATTER3D(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "CHART_SCATTER3D", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmChartScatter3D(p0...)
}

// gen_GEOMAP
//
// syntax: GEOMAP(...interface {})
func (x *Node) gen_GEOMAP(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "GEOMAP", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmGeoMap(p0...)
}

// gen_separator
//
// syntax: separator(uint8)
func (x *Node) gen_separator(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("separator", 1, len(args))
	}
	p0, err := convByte(args, 0, "separator", "uint8")
	if err != nil {
		return nil, err
	}
	ret := x.fmSeparator(p0)
	return ret, nil
}

// gen_trimspace
//
// syntax: trimspace(bool)
func (x *Node) gen_trimspace(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("trimspace", 1, len(args))
	}
	p0, err := convBool(args, 0, "trimspace", "bool")
	if err != nil {
		return nil, err
	}
	ret := x.fmTrimspace(p0)
	return ret, nil
}

// gen_file
//
// syntax: file(string)
func (x *Node) gen_file(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("file", 1, len(args))
	}
	p0, err := convString(args, 0, "file", "string")
	if err != nil {
		return nil, err
	}
	return x.fmFile(p0)
}

// gen_charset
//
// syntax: charset(string)
func (x *Node) gen_charset(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("charset", 1, len(args))
	}
	p0, err := convString(args, 0, "charset", "string")
	if err != nil {
		return nil, err
	}
	return x.fmCharset(p0)
}

// gen_STRING
//
// syntax: STRING(, ...interface {})
func (x *Node) gen_STRING(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("STRING", 1, len(args))
	}
	p0, err := convAny(args, 0, "STRING", "interface {}")
	if err != nil {
		return nil, err
	}
	p1 := []interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convAny(args, n, "STRING", "...interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	return x.fmString(p0, p1...)
}

// gen_BYTES
//
// syntax: BYTES(, ...interface {})
func (x *Node) gen_BYTES(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("BYTES", 1, len(args))
	}
	p0, err := convAny(args, 0, "BYTES", "interface {}")
	if err != nil {
		return nil, err
	}
	p1 := []interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convAny(args, n, "BYTES", "...interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	return x.fmBytes(p0, p1...)
}

// gen_col
//
// syntax: col(...interface {})
func (x *Node) gen_col(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "col", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmCol(p0...)
}

// gen_field
//
// syntax: field(...interface {})
func (x *Node) gen_field(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "field", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmField(p0...)
}

// gen_datetimeType
//
// syntax: datetimeType(...interface {})
func (x *Node) gen_datetimeType(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "datetimeType", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmDatetimeType(p0...)
}

// gen_stringType
//
// syntax: stringType(...interface {})
func (x *Node) gen_stringType(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "stringType", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmStringType(p0...)
}

// gen_doubleType
//
// syntax: doubleType(...interface {})
func (x *Node) gen_doubleType(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "doubleType", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmDoubleType(p0...)
}

// gen_simplex
//
// syntax: simplex(int64, float64, ...float64)
func (x *Node) gen_simplex(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("simplex", 2, len(args))
	}
	p0, err := convInt64(args, 0, "simplex", "int64")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "simplex", "float64")
	if err != nil {
		return nil, err
	}
	p2 := []float64{}
	for n := 2; n < len(args); n++ {
		argv, err := convFloat64(args, n, "simplex", "...float64")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return x.fmSimplex(p0, p1, p2...)
}

// gen_random
//
// syntax: random()
func (x *Node) gen_random(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, ErrInvalidNumOfArgs("random", 0, len(args))
	}
	ret := x.fmRandom()
	return ret, nil
}

// gen_parseFloat
//
// syntax: parseFloat(string)
func (x *Node) gen_parseFloat(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("parseFloat", 1, len(args))
	}
	p0, err := convString(args, 0, "parseFloat", "string")
	if err != nil {
		return nil, err
	}
	return x.fmParseFloat(p0)
}

// gen_parseBool
//
// syntax: parseBool(string)
func (x *Node) gen_parseBool(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("parseBool", 1, len(args))
	}
	p0, err := convString(args, 0, "parseBool", "string")
	if err != nil {
		return nil, err
	}
	return x.fmParseBoolean(p0)
}

// gen_strTrimSpace
//
// syntax: strTrimSpace(string)
func (x *Node) gen_strTrimSpace(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("strTrimSpace", 1, len(args))
	}
	p0, err := convString(args, 0, "strTrimSpace", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrTrimSpace(p0)
	return ret, nil
}

// gen_strTrimPrefix
//
// syntax: strTrimPrefix(string, string)
func (x *Node) gen_strTrimPrefix(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("strTrimPrefix", 2, len(args))
	}
	p0, err := convString(args, 0, "strTrimPrefix", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "strTrimPrefix", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrTrimPrefix(p0, p1)
	return ret, nil
}

// gen_strTrimSuffix
//
// syntax: strTrimSuffix(string, string)
func (x *Node) gen_strTrimSuffix(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("strTrimSuffix", 2, len(args))
	}
	p0, err := convString(args, 0, "strTrimSuffix", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "strTrimSuffix", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrTrimSuffix(p0, p1)
	return ret, nil
}

// gen_strReplaceAll
//
// syntax: strReplaceAll(string, string, string)
func (x *Node) gen_strReplaceAll(args ...any) (any, error) {
	if len(args) != 3 {
		return nil, ErrInvalidNumOfArgs("strReplaceAll", 3, len(args))
	}
	p0, err := convString(args, 0, "strReplaceAll", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "strReplaceAll", "string")
	if err != nil {
		return nil, err
	}
	p2, err := convString(args, 2, "strReplaceAll", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrReplaceAll(p0, p1, p2)
	return ret, nil
}

// gen_strReplace
//
// syntax: strReplace(string, string, string, int)
func (x *Node) gen_strReplace(args ...any) (any, error) {
	if len(args) != 4 {
		return nil, ErrInvalidNumOfArgs("strReplace", 4, len(args))
	}
	p0, err := convString(args, 0, "strReplace", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "strReplace", "string")
	if err != nil {
		return nil, err
	}
	p2, err := convString(args, 2, "strReplace", "string")
	if err != nil {
		return nil, err
	}
	p3, err := convInt(args, 3, "strReplace", "int")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrReplace(p0, p1, p2, p3)
	return ret, nil
}

// gen_strHasPrefix
//
// syntax: strHasPrefix(string, string)
func (x *Node) gen_strHasPrefix(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("strHasPrefix", 2, len(args))
	}
	p0, err := convString(args, 0, "strHasPrefix", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "strHasPrefix", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrHasPrefix(p0, p1)
	return ret, nil
}

// gen_strHasSuffix
//
// syntax: strHasSuffix(string, string)
func (x *Node) gen_strHasSuffix(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("strHasSuffix", 2, len(args))
	}
	p0, err := convString(args, 0, "strHasSuffix", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "strHasSuffix", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrHasSuffix(p0, p1)
	return ret, nil
}

// gen_strSprintf
//
// syntax: strSprintf(string, ...interface {})
func (x *Node) gen_strSprintf(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("strSprintf", 1, len(args))
	}
	p0, err := convString(args, 0, "strSprintf", "string")
	if err != nil {
		return nil, err
	}
	p1 := []interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convAny(args, n, "strSprintf", "...interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmStrSprintf(p0, p1...)
	return ret, nil
}

// gen_strSub
//
// syntax: strSub(string, ...int)
func (x *Node) gen_strSub(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("strSub", 1, len(args))
	}
	p0, err := convString(args, 0, "strSub", "string")
	if err != nil {
		return nil, err
	}
	p1 := []int{}
	for n := 1; n < len(args); n++ {
		argv, err := convInt(args, n, "strSub", "...int")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmStrSub(p0, p1...)
	return ret, nil
}

// gen_strToUpper
//
// syntax: strToUpper(string)
func (x *Node) gen_strToUpper(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("strToUpper", 1, len(args))
	}
	p0, err := convString(args, 0, "strToUpper", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrToUpper(p0)
	return ret, nil
}

// gen_strToLower
//
// syntax: strToLower(string)
func (x *Node) gen_strToLower(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("strToLower", 1, len(args))
	}
	p0, err := convString(args, 0, "strToLower", "string")
	if err != nil {
		return nil, err
	}
	ret := x.fmStrToLower(p0)
	return ret, nil
}

// gen_freq
//
// syntax: freq(float64, float64, ...float64)
func (x *Node) gen_freq(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("freq", 2, len(args))
	}
	p0, err := convFloat64(args, 0, "freq", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "freq", "float64")
	if err != nil {
		return nil, err
	}
	p2 := []float64{}
	for n := 2; n < len(args); n++ {
		argv, err := convFloat64(args, n, "freq", "...float64")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := x.fmFreq(p0, p1, p2...)
	return ret, nil
}

// gen_oscillator
//
// syntax: oscillator(...interface {})
func (x *Node) gen_oscillator(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "oscillator", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmOscillator(p0...)
}

// gen_sphere
//
// syntax: sphere(float64, float64)
func (x *Node) gen_sphere(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("sphere", 2, len(args))
	}
	p0, err := convFloat64(args, 0, "sphere", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "sphere", "float64")
	if err != nil {
		return nil, err
	}
	ret := x.fmSphere(p0, p1)
	return ret, nil
}

// gen_json
//
// syntax: json(string)
func (x *Node) gen_json(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("json", 1, len(args))
	}
	p0, err := convString(args, 0, "json", "string")
	if err != nil {
		return nil, err
	}
	return x.fmJsonData(p0)
}

// gen_csv
//
// syntax: csv(string)
func (x *Node) gen_csv(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("csv", 1, len(args))
	}
	p0, err := convString(args, 0, "csv", "string")
	if err != nil {
		return nil, err
	}
	return x.fmCsvData(p0)
}

// gen_FAKE
//
// syntax: FAKE()
func (x *Node) gen_FAKE(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("FAKE", 1, len(args))
	}
	p0, err := convAny(args, 0, "FAKE", "interface {}")
	if err != nil {
		return nil, err
	}
	return x.fmFake(p0)
}

// gen_GROUP
//
// syntax: GROUP(...interface {})
func (x *Node) gen_GROUP(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "GROUP", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := x.fmGroup(p0...)
	return ret, nil
}

// gen_by
//
// syntax: by(, ...string)
func (x *Node) gen_by(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("by", 1, len(args))
	}
	p0, err := convAny(args, 0, "by", "interface {}")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "by", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmBy(p0, p1...)
	return ret, nil
}

// gen_first
//
// syntax: first(float64, ...string)
func (x *Node) gen_first(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("first", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "first", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "first", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmFirst(p0, p1...)
	return ret, nil
}

// gen_last
//
// syntax: last(float64, ...string)
func (x *Node) gen_last(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("last", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "last", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "last", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmLast(p0, p1...)
	return ret, nil
}

// gen_min
//
// syntax: min(float64, ...interface {})
func (x *Node) gen_min(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("min", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "min", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convAny(args, n, "min", "...interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	return x.fmMin(p0, p1...)
}

// gen_max
//
// syntax: max(float64, ...interface {})
func (x *Node) gen_max(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("max", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "max", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := convAny(args, n, "max", "...interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	return x.fmMax(p0, p1...)
}

// gen_sum
//
// syntax: sum(float64, ...string)
func (x *Node) gen_sum(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("sum", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "sum", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "sum", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmSum(p0, p1...)
	return ret, nil
}

// gen_mean
//
// syntax: mean(float64, ...string)
func (x *Node) gen_mean(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("mean", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "mean", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "mean", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmMean(p0, p1...)
	return ret, nil
}

// gen_median
//
// syntax: median(float64, ...string)
func (x *Node) gen_median(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("median", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "median", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "median", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmMedian(p0, p1...)
	return ret, nil
}

// gen_medianInterpolated
//
// syntax: medianInterpolated(float64, ...string)
func (x *Node) gen_medianInterpolated(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("medianInterpolated", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "medianInterpolated", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "medianInterpolated", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmMedianInterpolated(p0, p1...)
	return ret, nil
}

// gen_stddev
//
// syntax: stddev(float64, ...string)
func (x *Node) gen_stddev(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("stddev", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "stddev", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "stddev", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmStdDev(p0, p1...)
	return ret, nil
}

// gen_stderr
//
// syntax: stderr(float64, ...string)
func (x *Node) gen_stderr(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("stderr", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "stderr", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "stderr", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmStdErr(p0, p1...)
	return ret, nil
}

// gen_entropy
//
// syntax: entropy(float64, ...string)
func (x *Node) gen_entropy(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("entropy", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "entropy", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "entropy", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmEntropy(p0, p1...)
	return ret, nil
}

// gen_mode
//
// syntax: mode(float64, ...string)
func (x *Node) gen_mode(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("mode", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "mode", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "mode", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmMode(p0, p1...)
	return ret, nil
}

// gen_avg
//
// syntax: avg(float64, ...string)
func (x *Node) gen_avg(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("avg", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "avg", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "avg", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmAvg(p0, p1...)
	return ret, nil
}

// gen_rss
//
// syntax: rss(float64, ...string)
func (x *Node) gen_rss(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("rss", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "rss", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "rss", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmRSS(p0, p1...)
	return ret, nil
}

// gen_rms
//
// syntax: rms(float64, ...string)
func (x *Node) gen_rms(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, ErrInvalidNumOfArgs("rms", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "rms", "float64")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := convString(args, n, "rms", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := x.fmRMS(p0, p1...)
	return ret, nil
}

// gen_INPUT
//
// syntax: INPUT(...interface {})
func (x *Node) gen_INPUT(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "INPUT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmINPUT(p0...)
}

// gen_OUTPUT
//
// syntax: OUTPUT(...interface {})
func (x *Node) gen_OUTPUT(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "OUTPUT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return x.fmOUTPUT(p0...)
}

// gen_tz
//
// syntax: tz(string)
func (x *Node) gen_tz(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("tz", 1, len(args))
	}
	p0, err := convString(args, 0, "tz", "string")
	if err != nil {
		return nil, err
	}
	return x.fmTZ(p0)
}

// gen_sep
//
// syntax: sep(uint8)
func (x *Node) gen_sep(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("sep", 1, len(args))
	}
	p0, err := convByte(args, 0, "sep", "uint8")
	if err != nil {
		return nil, err
	}
	ret := x.fmSeparator(p0)
	return ret, nil
}

// gen_assetHost
//
// syntax: assetHost(string)
func (x *Node) gen_assetHost(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("assetHost", 1, len(args))
	}
	p0, err := convString(args, 0, "assetHost", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.AssetHost(p0)
	return ret, nil
}

// gen_autoRotate
//
// syntax: autoRotate(float64)
func (x *Node) gen_autoRotate(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("autoRotate", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "autoRotate", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.AutoRotate(p0)
	return ret, nil
}

// gen_boxDrawBorder
//
// syntax: boxDrawBorder(bool)
func (x *Node) gen_boxDrawBorder(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("boxDrawBorder", 1, len(args))
	}
	p0, err := convBool(args, 0, "boxDrawBorder", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.BoxDrawBorder(p0)
	return ret, nil
}

// gen_boxSeparateColumns
//
// syntax: boxSeparateColumns(bool)
func (x *Node) gen_boxSeparateColumns(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("boxSeparateColumns", 1, len(args))
	}
	p0, err := convBool(args, 0, "boxSeparateColumns", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.BoxSeparateColumns(p0)
	return ret, nil
}

// gen_boxStyle
//
// syntax: boxStyle(string)
func (x *Node) gen_boxStyle(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("boxStyle", 1, len(args))
	}
	p0, err := convString(args, 0, "boxStyle", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.BoxStyle(p0)
	return ret, nil
}

// gen_brief
//
// syntax: brief(bool)
func (x *Node) gen_brief(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("brief", 1, len(args))
	}
	p0, err := convBool(args, 0, "brief", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Brief(p0)
	return ret, nil
}

// gen_briefCount
//
// syntax: briefCount(int)
func (x *Node) gen_briefCount(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("briefCount", 1, len(args))
	}
	p0, err := convInt(args, 0, "briefCount", "int")
	if err != nil {
		return nil, err
	}
	ret := opts.BriefCount(p0)
	return ret, nil
}

// gen_charsetEncoding
//
// syntax: charsetEncoding(Encoding)
func (x *Node) gen_charsetEncoding(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("charsetEncoding", 1, len(args))
	}
	p0, err := convCharset(args, 0, "charsetEncoding", "encoding.Encoding")
	if err != nil {
		return nil, err
	}
	ret := opts.CharsetEncoding(p0)
	return ret, nil
}

// gen_chartCDN
//
// syntax: chartCDN(string)
func (x *Node) gen_chartCDN(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("chartCDN", 1, len(args))
	}
	p0, err := convString(args, 0, "chartCDN", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.ChartCDN(p0)
	return ret, nil
}

// gen_chartDispatchAction
//
// syntax: chartDispatchAction(string)
func (x *Node) gen_chartDispatchAction(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("chartDispatchAction", 1, len(args))
	}
	p0, err := convString(args, 0, "chartDispatchAction", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.ChartDispatchAction(p0)
	return ret, nil
}

// gen_chartId
//
// syntax: chartId(string)
func (x *Node) gen_chartId(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("chartId", 1, len(args))
	}
	p0, err := convString(args, 0, "chartId", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.ChartId(p0)
	return ret, nil
}

// gen_chartJSCode
//
// syntax: chartJSCode(string)
func (x *Node) gen_chartJSCode(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("chartJSCode", 1, len(args))
	}
	p0, err := convString(args, 0, "chartJSCode", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.ChartJSCode(p0)
	return ret, nil
}

// gen_chartJson
//
// syntax: chartJson(bool)
func (x *Node) gen_chartJson(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("chartJson", 1, len(args))
	}
	p0, err := convBool(args, 0, "chartJson", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.ChartJson(p0)
	return ret, nil
}

// gen_chartOption
//
// syntax: chartOption(string)
func (x *Node) gen_chartOption(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("chartOption", 1, len(args))
	}
	p0, err := convString(args, 0, "chartOption", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.ChartOption(p0)
	return ret, nil
}

// gen_columnTypes
//
// syntax: columnTypes(...string)
func (x *Node) gen_columnTypes(args ...any) (any, error) {
	p0 := []string{}
	for n := 0; n < len(args); n++ {
		argv, err := convString(args, n, "columnTypes", "...string")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.ColumnTypes(p0...)
	return ret, nil
}

// gen_columns
//
// syntax: columns(...string)
func (x *Node) gen_columns(args ...any) (any, error) {
	p0 := []string{}
	for n := 0; n < len(args); n++ {
		argv, err := convString(args, n, "columns", "...string")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.Columns(p0...)
	return ret, nil
}

// gen_dataZoom
//
// syntax: dataZoom(string, float32, float32)
func (x *Node) gen_dataZoom(args ...any) (any, error) {
	if len(args) != 3 {
		return nil, ErrInvalidNumOfArgs("dataZoom", 3, len(args))
	}
	p0, err := convString(args, 0, "dataZoom", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat32(args, 1, "dataZoom", "float32")
	if err != nil {
		return nil, err
	}
	p2, err := convFloat32(args, 2, "dataZoom", "float32")
	if err != nil {
		return nil, err
	}
	ret := opts.DataZoom(p0, p1, p2)
	return ret, nil
}

// gen_delimiter
//
// syntax: delimiter(string)
func (x *Node) gen_delimiter(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("delimiter", 1, len(args))
	}
	p0, err := convString(args, 0, "delimiter", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Delimiter(p0)
	return ret, nil
}

// gen_geoMapJson
//
// syntax: geoMapJson(bool)
func (x *Node) gen_geoMapJson(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("geoMapJson", 1, len(args))
	}
	p0, err := convBool(args, 0, "geoMapJson", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.GeoMapJson(p0)
	return ret, nil
}

// gen_globalOptions
//
// syntax: globalOptions(string)
func (x *Node) gen_globalOptions(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("globalOptions", 1, len(args))
	}
	p0, err := convString(args, 0, "globalOptions", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.GlobalOptions(p0)
	return ret, nil
}

// gen_gridSize
//
// syntax: gridSize(...float64)
func (x *Node) gen_gridSize(args ...any) (any, error) {
	p0 := []float64{}
	for n := 0; n < len(args); n++ {
		argv, err := convFloat64(args, n, "gridSize", "...float64")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.GridSize(p0...)
	return ret, nil
}

// gen_header
//
// syntax: header(bool)
func (x *Node) gen_header(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("header", 1, len(args))
	}
	p0, err := convBool(args, 0, "header", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Header(p0)
	return ret, nil
}

// gen_heading
//
// syntax: heading(bool)
func (x *Node) gen_heading(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("heading", 1, len(args))
	}
	p0, err := convBool(args, 0, "heading", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Heading(p0)
	return ret, nil
}

// gen_html
//
// syntax: html(bool)
func (x *Node) gen_html(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("html", 1, len(args))
	}
	p0, err := convBool(args, 0, "html", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Html(p0)
	return ret, nil
}

// gen_icon
//
// syntax: icon(string, string)
func (x *Node) gen_icon(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("icon", 2, len(args))
	}
	p0, err := convString(args, 0, "icon", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "icon", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Icon(p0, p1)
	return ret, nil
}

// gen_initialLocation
//
// syntax: initialLocation(, int)
func (x *Node) gen_initialLocation(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("initialLocation", 2, len(args))
	}
	p0, err := convLatLng(args, 0, "initialLocation", "*nums.LatLng")
	if err != nil {
		return nil, err
	}
	p1, err := convInt(args, 1, "initialLocation", "int")
	if err != nil {
		return nil, err
	}
	ret := opts.InitialLocation(p0, p1)
	return ret, nil
}

// gen_inputStream
//
// syntax: inputStream(InputStream)
func (x *Node) gen_inputStream(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("inputStream", 1, len(args))
	}
	p0, err := convInputStream(args, 0, "inputStream", "spec.InputStream")
	if err != nil {
		return nil, err
	}
	ret := opts.InputStream(p0)
	return ret, nil
}

// gen_lineWidth
//
// syntax: lineWidth(float64)
func (x *Node) gen_lineWidth(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("lineWidth", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "lineWidth", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.LineWidth(p0)
	return ret, nil
}

// gen_logger
//
// syntax: logger(Logger)
func (x *Node) gen_logger(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("logger", 1, len(args))
	}
	p0, err := convLogger(args, 0, "logger", "logger.Logger")
	if err != nil {
		return nil, err
	}
	ret := opts.Logger(p0)
	return ret, nil
}

// gen_mapId
//
// syntax: mapId(string)
func (x *Node) gen_mapId(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("mapId", 1, len(args))
	}
	p0, err := convString(args, 0, "mapId", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.MapId(p0)
	return ret, nil
}

// gen_markAreaNameCoord
//
// syntax: markAreaNameCoord(, , string, string, float64)
func (x *Node) gen_markAreaNameCoord(args ...any) (any, error) {
	if len(args) != 5 {
		return nil, ErrInvalidNumOfArgs("markAreaNameCoord", 5, len(args))
	}
	p0, err := convAny(args, 0, "markAreaNameCoord", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convAny(args, 1, "markAreaNameCoord", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := convString(args, 2, "markAreaNameCoord", "string")
	if err != nil {
		return nil, err
	}
	p3, err := convString(args, 3, "markAreaNameCoord", "string")
	if err != nil {
		return nil, err
	}
	p4, err := convFloat64(args, 4, "markAreaNameCoord", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.MarkAreaNameCoord(p0, p1, p2, p3, p4)
	return ret, nil
}

// gen_markLineXAxisCoord
//
// syntax: markLineXAxisCoord(, string)
func (x *Node) gen_markLineXAxisCoord(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("markLineXAxisCoord", 2, len(args))
	}
	p0, err := convAny(args, 0, "markLineXAxisCoord", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "markLineXAxisCoord", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.MarkLineXAxisCoord(p0, p1)
	return ret, nil
}

// gen_markLineYAxisCoord
//
// syntax: markLineYAxisCoord(, string)
func (x *Node) gen_markLineYAxisCoord(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("markLineYAxisCoord", 2, len(args))
	}
	p0, err := convAny(args, 0, "markLineYAxisCoord", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "markLineYAxisCoord", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.MarkLineYAxisCoord(p0, p1)
	return ret, nil
}

// gen_marker
//
// syntax: marker(GeoMarker)
func (x *Node) gen_marker(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("marker", 1, len(args))
	}
	p0, err := convGeoMarker(args, 0, "marker", "nums.GeoMarker")
	if err != nil {
		return nil, err
	}
	ret := opts.Marker(p0)
	return ret, nil
}

// gen_opacity
//
// syntax: opacity(float64)
func (x *Node) gen_opacity(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("opacity", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "opacity", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.Opacity(p0)
	return ret, nil
}

// gen_outputStream
//
// syntax: outputStream(OutputStream)
func (x *Node) gen_outputStream(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("outputStream", 1, len(args))
	}
	p0, err := convOutputStream(args, 0, "outputStream", "spec.OutputStream")
	if err != nil {
		return nil, err
	}
	ret := opts.OutputStream(p0)
	return ret, nil
}

// gen_plugins
//
// syntax: plugins(...string)
func (x *Node) gen_plugins(args ...any) (any, error) {
	p0 := []string{}
	for n := 0; n < len(args); n++ {
		argv, err := convString(args, n, "plugins", "...string")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.Plugins(p0...)
	return ret, nil
}

// gen_pointStyle
//
// syntax: pointStyle(string, string, string)
func (x *Node) gen_pointStyle(args ...any) (any, error) {
	if len(args) != 3 {
		return nil, ErrInvalidNumOfArgs("pointStyle", 3, len(args))
	}
	p0, err := convString(args, 0, "pointStyle", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "pointStyle", "string")
	if err != nil {
		return nil, err
	}
	p2, err := convString(args, 2, "pointStyle", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.PointStyle(p0, p1, p2)
	return ret, nil
}

// gen_precision
//
// syntax: precision(int)
func (x *Node) gen_precision(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("precision", 1, len(args))
	}
	p0, err := convInt(args, 0, "precision", "int")
	if err != nil {
		return nil, err
	}
	ret := opts.Precision(p0)
	return ret, nil
}

// gen_rownum
//
// syntax: rownum(bool)
func (x *Node) gen_rownum(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("rownum", 1, len(args))
	}
	p0, err := convBool(args, 0, "rownum", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Rownum(p0)
	return ret, nil
}

// gen_seriesLabels
//
// syntax: seriesLabels(...string)
func (x *Node) gen_seriesLabels(args ...any) (any, error) {
	p0 := []string{}
	for n := 0; n < len(args); n++ {
		argv, err := convString(args, n, "seriesLabels", "...string")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.SeriesLabels(p0...)
	return ret, nil
}

// gen_seriesOptions
//
// syntax: seriesOptions(...string)
func (x *Node) gen_seriesOptions(args ...any) (any, error) {
	p0 := []string{}
	for n := 0; n < len(args); n++ {
		argv, err := convString(args, n, "seriesOptions", "...string")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.SeriesOptions(p0...)
	return ret, nil
}

// gen_showGrid
//
// syntax: showGrid(bool)
func (x *Node) gen_showGrid(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("showGrid", 1, len(args))
	}
	p0, err := convBool(args, 0, "showGrid", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.ShowGrid(p0)
	return ret, nil
}

// gen_size
//
// syntax: size(string, string)
func (x *Node) gen_size(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("size", 2, len(args))
	}
	p0, err := convString(args, 0, "size", "string")
	if err != nil {
		return nil, err
	}
	p1, err := convString(args, 1, "size", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Size(p0, p1)
	return ret, nil
}

// gen_substituteNull
//
// syntax: substituteNull(string)
func (x *Node) gen_substituteNull(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("substituteNull", 1, len(args))
	}
	p0, err := convString(args, 0, "substituteNull", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.SubstituteNull(p0)
	return ret, nil
}

// gen_subtitle
//
// syntax: subtitle(string)
func (x *Node) gen_subtitle(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("subtitle", 1, len(args))
	}
	p0, err := convString(args, 0, "subtitle", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Subtitle(p0)
	return ret, nil
}

// gen_tableName
//
// syntax: tableName(string)
func (x *Node) gen_tableName(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("tableName", 1, len(args))
	}
	p0, err := convString(args, 0, "tableName", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.TableName(p0)
	return ret, nil
}

// gen_theme
//
// syntax: theme(string)
func (x *Node) gen_theme(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("theme", 1, len(args))
	}
	p0, err := convString(args, 0, "theme", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Theme(p0)
	return ret, nil
}

// gen_tileGrayscale
//
// syntax: tileGrayscale(float64)
func (x *Node) gen_tileGrayscale(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("tileGrayscale", 1, len(args))
	}
	p0, err := convFloat64(args, 0, "tileGrayscale", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.TileGrayscale(p0)
	return ret, nil
}

// gen_tileOption
//
// syntax: tileOption(string)
func (x *Node) gen_tileOption(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("tileOption", 1, len(args))
	}
	p0, err := convString(args, 0, "tileOption", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.TileOption(p0)
	return ret, nil
}

// gen_tileTemplate
//
// syntax: tileTemplate(string)
func (x *Node) gen_tileTemplate(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("tileTemplate", 1, len(args))
	}
	p0, err := convString(args, 0, "tileTemplate", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.TileTemplate(p0)
	return ret, nil
}

// gen_timeLocation
//
// syntax: timeLocation()
func (x *Node) gen_timeLocation(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("timeLocation", 1, len(args))
	}
	p0, err := convTimeLocation(args, 0, "timeLocation", "*time.Location")
	if err != nil {
		return nil, err
	}
	ret := opts.TimeLocation(p0)
	return ret, nil
}

// gen_timeformat
//
// syntax: timeformat(string)
func (x *Node) gen_timeformat(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("timeformat", 1, len(args))
	}
	p0, err := convString(args, 0, "timeformat", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Timeformat(p0)
	return ret, nil
}

// gen_title
//
// syntax: title(string)
func (x *Node) gen_title(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("title", 1, len(args))
	}
	p0, err := convString(args, 0, "title", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Title(p0)
	return ret, nil
}

// gen_toolboxDataView
//
// syntax: toolboxDataView()
func (x *Node) gen_toolboxDataView(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, ErrInvalidNumOfArgs("toolboxDataView", 0, len(args))
	}
	ret := opts.ToolboxDataView()
	return ret, nil
}

// gen_toolboxDataZoom
//
// syntax: toolboxDataZoom()
func (x *Node) gen_toolboxDataZoom(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, ErrInvalidNumOfArgs("toolboxDataZoom", 0, len(args))
	}
	ret := opts.ToolboxDataZoom()
	return ret, nil
}

// gen_toolboxSaveAsImage
//
// syntax: toolboxSaveAsImage(string)
func (x *Node) gen_toolboxSaveAsImage(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("toolboxSaveAsImage", 1, len(args))
	}
	p0, err := convString(args, 0, "toolboxSaveAsImage", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.ToolboxSaveAsImage(p0)
	return ret, nil
}

// gen_transcoder
//
// syntax: transcoder(Transcoder)
func (x *Node) gen_transcoder(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("transcoder", 1, len(args))
	}
	p0, err := convTranscoder(args, 0, "transcoder", "transcoder.Transcoder")
	if err != nil {
		return nil, err
	}
	ret := opts.Transcoder(p0)
	return ret, nil
}

// gen_transpose
//
// syntax: transpose(bool)
func (x *Node) gen_transpose(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, ErrInvalidNumOfArgs("transpose", 1, len(args))
	}
	p0, err := convBool(args, 0, "transpose", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Transpose(p0)
	return ret, nil
}

// gen_visualMap
//
// syntax: visualMap(float64, float64)
func (x *Node) gen_visualMap(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, ErrInvalidNumOfArgs("visualMap", 2, len(args))
	}
	p0, err := convFloat64(args, 0, "visualMap", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "visualMap", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.VisualMap(p0, p1)
	return ret, nil
}

// gen_visualMapColor
//
// syntax: visualMapColor(float64, float64, ...string)
func (x *Node) gen_visualMapColor(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, ErrInvalidNumOfArgs("visualMapColor", 2, len(args))
	}
	p0, err := convFloat64(args, 0, "visualMapColor", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := convFloat64(args, 1, "visualMapColor", "float64")
	if err != nil {
		return nil, err
	}
	p2 := []string{}
	for n := 2; n < len(args); n++ {
		argv, err := convString(args, n, "visualMapColor", "...string")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := opts.VisualMapColor(p0, p1, p2...)
	return ret, nil
}

// gen_xAxis
//
// syntax: xAxis(...interface {})
func (x *Node) gen_xAxis(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "xAxis", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.XAxis(p0...)
	return ret, nil
}

// gen_yAxis
//
// syntax: yAxis(...interface {})
func (x *Node) gen_yAxis(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "yAxis", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.YAxis(p0...)
	return ret, nil
}

// gen_zAxis
//
// syntax: zAxis(...interface {})
func (x *Node) gen_zAxis(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := convAny(args, n, "zAxis", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.ZAxis(p0...)
	return ret, nil
}
