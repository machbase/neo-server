//go:generate go run fx_generate.go

package fx

// Code generated by go generate; DO NOT EDIT.

import (
	"math"

	"github.com/machbase/neo-server/mods/codec/opts"
	"github.com/machbase/neo-server/mods/expression"
	"github.com/machbase/neo-server/mods/nums"
	"github.com/machbase/neo-server/mods/tql/conv"
	"github.com/machbase/neo-server/mods/tql/maps"
)

var GenFunctions = map[string]expression.Function{
	// math
	"sin":   gen_sin,
	"cos":   gen_cos,
	"tan":   gen_tan,
	"exp":   gen_exp,
	"exp2":  gen_exp2,
	"log":   gen_log,
	"log10": gen_log10,
	// nums
	"count":      nums.Count,
	"len":        nums.Len,
	"element":    nums.Element,
	"round":      gen_round,
	"linspace":   gen_linspace,
	"linspace50": gen_linspace50,
	"meshgrid":   gen_meshgrid,
	// maps.time
	"time":      gen_time,
	"timeAdd":   gen_timeAdd,
	"roundTime": gen_roundTime,
	"range":     gen_range,
	// maps.monad
	"TAKE":       gen_TAKE,
	"DROP":       gen_DROP,
	"FILTER":     gen_FILTER,
	"FLATTEN":    gen_FLATTEN,
	"GROUPBYKEY": gen_GROUPBYKEY,
	"POPKEY":     gen_POPKEY,
	"PUSHKEY":    gen_PUSHKEY,
	"SCRIPT":     gen_SCRIPT,
	"lazy":       gen_lazy,
	// maps.dbsrc
	"from":    gen_from,
	"limit":   gen_limit,
	"between": gen_between,
	"dump":    gen_dump,
	"QUERY":   gen_QUERY,
	"SQL":     gen_SQL,
	// maps.dbsink
	"table":  gen_table,
	"tag":    gen_tag,
	"INSERT": gen_INSERT,
	"APPEND": gen_APPEND,
	// maps.fourier
	"minHz": gen_minHz,
	"maxHz": gen_maxHz,
	"FFT":   gen_FFT,
	// maps.encoder
	"CSV":             gen_CSV,
	"JSON":            gen_JSON,
	"MARKDOWN":        gen_MARKDOWN,
	"CHART_LINE":      gen_CHART_LINE,
	"CHART_SCATTER":   gen_CHART_SCATTER,
	"CHART_BAR":       gen_CHART_BAR,
	"CHART_LINE3D":    gen_CHART_LINE3D,
	"CHART_BAR3D":     gen_CHART_BAR3D,
	"CHART_SURFACE3D": gen_CHART_SURFACE3D,
	"CHART_SCATTER3D": gen_CHART_SCATTER3D,
	// maps.bytes
	"separator": gen_separator,
	"file":      gen_file,
	"STRING":    gen_STRING,
	"BYTES":     gen_BYTES,
	// maps.csv
	"col":          gen_col,
	"field":        gen_field,
	"header":       gen_header,
	"datetimeType": gen_datetimeType,
	"stringType":   gen_stringType,
	"doubleType":   gen_doubleType,
	"freq":         gen_freq,
	"oscillator":   gen_oscillator,
	"sphere":       gen_sphere,
	"FAKE":         gen_FAKE,
	// maps.input
	"INPUT": gen_INPUT,
	// maps.output
	"OUTPUT": gen_OUTPUT,
	// aliases
	"markArea":  markArea,
	"markXAxis": gen_markLineXAxisCoord,
	"markYAxis": gen_markLineYAxisCoord,
	"tz":        gen_tz,
	"sep":       gen_sep,
	// codec.opts
	"assetHost":          gen_assetHost,
	"autoRotate":         gen_autoRotate,
	"boxDrawBorder":      gen_boxDrawBorder,
	"boxSeparateColumns": gen_boxSeparateColumns,
	"boxStyle":           gen_boxStyle,
	"brief":              gen_brief,
	"briefCount":         gen_briefCount,
	"chartJson":          gen_chartJson,
	"columnTypes":        gen_columnTypes,
	"columns":            gen_columns,
	"dataZoom":           gen_dataZoom,
	"delimiter":          gen_delimiter,
	"gridSize":           gen_gridSize,
	"heading":            gen_heading,
	"html":               gen_html,
	"inputStream":        gen_inputStream,
	"lineWidth":          gen_lineWidth,
	"markAreaNameCoord":  gen_markAreaNameCoord,
	"markLineXAxisCoord": gen_markLineXAxisCoord,
	"markLineYAxisCoord": gen_markLineYAxisCoord,
	"opacity":            gen_opacity,
	"outputStream":       gen_outputStream,
	"precision":          gen_precision,
	"rownum":             gen_rownum,
	"seriesLabels":       gen_seriesLabels,
	"showGrid":           gen_showGrid,
	"size":               gen_size,
	"subtitle":           gen_subtitle,
	"tableName":          gen_tableName,
	"theme":              gen_theme,
	"timeLocation":       gen_timeLocation,
	"timeformat":         gen_timeformat,
	"title":              gen_title,
	"transcoder":         gen_transcoder,
	"transpose":          gen_transpose,
	"visualMap":          gen_visualMap,
	"xAxis":              gen_xAxis,
	"yAxis":              gen_yAxis,
	"zAxis":              gen_zAxis,
}

// gen_sin
//
// syntax: sin(float64)
func gen_sin(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("sin", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "sin", "float64")
	if err != nil {
		return nil, err
	}
	ret := math.Sin(p0)
	return ret, nil
}

// gen_cos
//
// syntax: cos(float64)
func gen_cos(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("cos", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "cos", "float64")
	if err != nil {
		return nil, err
	}
	ret := math.Cos(p0)
	return ret, nil
}

// gen_tan
//
// syntax: tan(float64)
func gen_tan(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("tan", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "tan", "float64")
	if err != nil {
		return nil, err
	}
	ret := math.Tan(p0)
	return ret, nil
}

// gen_exp
//
// syntax: exp(float64)
func gen_exp(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("exp", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "exp", "float64")
	if err != nil {
		return nil, err
	}
	ret := math.Exp(p0)
	return ret, nil
}

// gen_exp2
//
// syntax: exp2(float64)
func gen_exp2(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("exp2", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "exp2", "float64")
	if err != nil {
		return nil, err
	}
	ret := math.Exp2(p0)
	return ret, nil
}

// gen_log
//
// syntax: log(float64)
func gen_log(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("log", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "log", "float64")
	if err != nil {
		return nil, err
	}
	ret := math.Log(p0)
	return ret, nil
}

// gen_log10
//
// syntax: log10(float64)
func gen_log10(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("log10", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "log10", "float64")
	if err != nil {
		return nil, err
	}
	ret := math.Log10(p0)
	return ret, nil
}

// gen_round
//
// syntax: round(int64, int64)
func gen_round(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("round", 2, len(args))
	}
	p0, err := conv.Int64(args, 0, "round", "int64")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Int64(args, 1, "round", "int64")
	if err != nil {
		return nil, err
	}
	ret := nums.Round(p0, p1)
	return ret, nil
}

// gen_linspace
//
// syntax: linspace(float64, float64, int)
func gen_linspace(args ...any) (any, error) {
	if len(args) != 3 {
		return nil, conv.ErrInvalidNumOfArgs("linspace", 3, len(args))
	}
	p0, err := conv.Float64(args, 0, "linspace", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Float64(args, 1, "linspace", "float64")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Int(args, 2, "linspace", "int")
	if err != nil {
		return nil, err
	}
	ret := nums.Linspace(p0, p1, p2)
	return ret, nil
}

// gen_linspace50
//
// syntax: linspace50(float64, float64)
func gen_linspace50(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("linspace50", 2, len(args))
	}
	p0, err := conv.Float64(args, 0, "linspace50", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Float64(args, 1, "linspace50", "float64")
	if err != nil {
		return nil, err
	}
	ret := nums.Linspace50(p0, p1)
	return ret, nil
}

// gen_meshgrid
//
// syntax: meshgrid([]float64, []float64)
func gen_meshgrid(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("meshgrid", 2, len(args))
	}
	p0, ok := args[0].([]float64)
	if !ok {
		return nil, conv.ErrWrongTypeOfArgs("meshgrid", 0, "[]float64", args[0])
	}
	p1, ok := args[1].([]float64)
	if !ok {
		return nil, conv.ErrWrongTypeOfArgs("meshgrid", 1, "[]float64", args[1])
	}
	ret := nums.Meshgrid(p0, p1)
	return ret, nil
}

// gen_time
//
// syntax: time()
func gen_time(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("time", 1, len(args))
	}
	p0, err := conv.Any(args, 0, "time", "interface {}")
	if err != nil {
		return nil, err
	}
	return maps.Time(p0)
}

// gen_timeAdd
//
// syntax: timeAdd(, )
func gen_timeAdd(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("timeAdd", 2, len(args))
	}
	p0, err := conv.Any(args, 0, "timeAdd", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "timeAdd", "interface {}")
	if err != nil {
		return nil, err
	}
	return maps.TimeAdd(p0, p1)
}

// gen_roundTime
//
// syntax: roundTime(, )
func gen_roundTime(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("roundTime", 2, len(args))
	}
	p0, err := conv.Any(args, 0, "roundTime", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "roundTime", "interface {}")
	if err != nil {
		return nil, err
	}
	return maps.RoundTime(p0, p1)
}

// gen_range
//
// syntax: range(, , ...interface {})
func gen_range(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, conv.ErrInvalidNumOfArgs("range", 2, len(args))
	}
	p0, err := conv.Any(args, 0, "range", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "range", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := conv.Any(args, n, "range", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return maps.ToTimeRange(p0, p1, p2...)
}

// gen_TAKE
//
// syntax: TAKE(, , , int)
func gen_TAKE(args ...any) (any, error) {
	if len(args) != 4 {
		return nil, conv.ErrInvalidNumOfArgs("TAKE", 4, len(args))
	}
	p0, err := conv.Context(args, 0, "TAKE", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "TAKE", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Any(args, 2, "TAKE", "interface {}")
	if err != nil {
		return nil, err
	}
	p3, err := conv.Int(args, 3, "TAKE", "int")
	if err != nil {
		return nil, err
	}
	ret := maps.Take(p0, p1, p2, p3)
	return ret, nil
}

// gen_DROP
//
// syntax: DROP(, , , int)
func gen_DROP(args ...any) (any, error) {
	if len(args) != 4 {
		return nil, conv.ErrInvalidNumOfArgs("DROP", 4, len(args))
	}
	p0, err := conv.Context(args, 0, "DROP", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "DROP", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Any(args, 2, "DROP", "interface {}")
	if err != nil {
		return nil, err
	}
	p3, err := conv.Int(args, 3, "DROP", "int")
	if err != nil {
		return nil, err
	}
	ret := maps.Drop(p0, p1, p2, p3)
	return ret, nil
}

// gen_FILTER
//
// syntax: FILTER(, , , bool)
func gen_FILTER(args ...any) (any, error) {
	if len(args) != 4 {
		return nil, conv.ErrInvalidNumOfArgs("FILTER", 4, len(args))
	}
	p0, err := conv.Context(args, 0, "FILTER", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "FILTER", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Any(args, 2, "FILTER", "interface {}")
	if err != nil {
		return nil, err
	}
	p3, err := conv.Bool(args, 3, "FILTER", "bool")
	if err != nil {
		return nil, err
	}
	ret := maps.Filter(p0, p1, p2, p3)
	return ret, nil
}

// gen_FLATTEN
//
// syntax: FLATTEN(, , )
func gen_FLATTEN(args ...any) (any, error) {
	if len(args) != 3 {
		return nil, conv.ErrInvalidNumOfArgs("FLATTEN", 3, len(args))
	}
	p0, err := conv.Context(args, 0, "FLATTEN", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "FLATTEN", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Any(args, 2, "FLATTEN", "interface {}")
	if err != nil {
		return nil, err
	}
	ret := maps.Flatten(p0, p1, p2)
	return ret, nil
}

// gen_GROUPBYKEY
//
// syntax: GROUPBYKEY(, , , ...interface {})
func gen_GROUPBYKEY(args ...any) (any, error) {
	if len(args) < 3 {
		return nil, conv.ErrInvalidNumOfArgs("GROUPBYKEY", 3, len(args))
	}
	p0, err := conv.Context(args, 0, "GROUPBYKEY", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "GROUPBYKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Any(args, 2, "GROUPBYKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	p3 := []interface{}{}
	for n := 3; n < len(args); n++ {
		argv, err := conv.Any(args, n, "GROUPBYKEY", "...interface {}")
		if err != nil {
			return nil, err
		}
		p3 = append(p3, argv)
	}
	ret := maps.GroupByKey(p0, p1, p2, p3...)
	return ret, nil
}

// gen_POPKEY
//
// syntax: POPKEY(, , , ...int)
func gen_POPKEY(args ...any) (any, error) {
	if len(args) < 3 {
		return nil, conv.ErrInvalidNumOfArgs("POPKEY", 3, len(args))
	}
	p0, err := conv.Context(args, 0, "POPKEY", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "POPKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Any(args, 2, "POPKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	p3 := []int{}
	for n := 3; n < len(args); n++ {
		argv, err := conv.Int(args, n, "POPKEY", "...int")
		if err != nil {
			return nil, err
		}
		p3 = append(p3, argv)
	}
	return maps.PopKey(p0, p1, p2, p3...)
}

// gen_PUSHKEY
//
// syntax: PUSHKEY(, , , )
func gen_PUSHKEY(args ...any) (any, error) {
	if len(args) != 4 {
		return nil, conv.ErrInvalidNumOfArgs("PUSHKEY", 4, len(args))
	}
	p0, err := conv.Context(args, 0, "PUSHKEY", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "PUSHKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Any(args, 2, "PUSHKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	p3, err := conv.Any(args, 3, "PUSHKEY", "interface {}")
	if err != nil {
		return nil, err
	}
	return maps.PushKey(p0, p1, p2, p3)
}

// gen_SCRIPT
//
// syntax: SCRIPT(, , , string)
func gen_SCRIPT(args ...any) (any, error) {
	if len(args) != 4 {
		return nil, conv.ErrInvalidNumOfArgs("SCRIPT", 4, len(args))
	}
	p0, err := conv.Context(args, 0, "SCRIPT", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "SCRIPT", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Any(args, 2, "SCRIPT", "interface {}")
	if err != nil {
		return nil, err
	}
	p3, err := conv.String(args, 3, "SCRIPT", "string")
	if err != nil {
		return nil, err
	}
	return maps.ScriptTengo(p0, p1, p2, p3)
}

// gen_lazy
//
// syntax: lazy(bool)
func gen_lazy(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("lazy", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "lazy", "bool")
	if err != nil {
		return nil, err
	}
	ret := maps.ToLazy(p0)
	return ret, nil
}

// gen_from
//
// syntax: from(string, string, ...string)
func gen_from(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, conv.ErrInvalidNumOfArgs("from", 2, len(args))
	}
	p0, err := conv.String(args, 0, "from", "string")
	if err != nil {
		return nil, err
	}
	p1, err := conv.String(args, 1, "from", "string")
	if err != nil {
		return nil, err
	}
	p2 := []string{}
	for n := 2; n < len(args); n++ {
		argv, err := conv.String(args, n, "from", "...string")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := maps.ToFrom(p0, p1, p2...)
	return ret, nil
}

// gen_limit
//
// syntax: limit(...int)
func gen_limit(args ...any) (any, error) {
	p0 := []int{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Int(args, n, "limit", "...int")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ToLimit(p0...)
	return ret, nil
}

// gen_between
//
// syntax: between(, , ...interface {})
func gen_between(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, conv.ErrInvalidNumOfArgs("between", 2, len(args))
	}
	p0, err := conv.Any(args, 0, "between", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "between", "interface {}")
	if err != nil {
		return nil, err
	}
	p2 := []interface{}{}
	for n := 2; n < len(args); n++ {
		argv, err := conv.Any(args, n, "between", "...interface {}")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	return maps.ToBetween(p0, p1, p2...)
}

// gen_dump
//
// syntax: dump(...bool)
func gen_dump(args ...any) (any, error) {
	p0 := []bool{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Bool(args, n, "dump", "...bool")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ToDump(p0...)
	return ret, nil
}

// gen_QUERY
//
// syntax: QUERY(...interface {})
func gen_QUERY(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "QUERY", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToQuery(p0...)
}

// gen_SQL
//
// syntax: SQL(string)
func gen_SQL(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("SQL", 1, len(args))
	}
	p0, err := conv.String(args, 0, "SQL", "string")
	if err != nil {
		return nil, err
	}
	ret := maps.ToSql(p0)
	return ret, nil
}

// gen_table
//
// syntax: table(string)
func gen_table(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("table", 1, len(args))
	}
	p0, err := conv.String(args, 0, "table", "string")
	if err != nil {
		return nil, err
	}
	ret := maps.ToTable(p0)
	return ret, nil
}

// gen_tag
//
// syntax: tag(string, ...string)
func gen_tag(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, conv.ErrInvalidNumOfArgs("tag", 1, len(args))
	}
	p0, err := conv.String(args, 0, "tag", "string")
	if err != nil {
		return nil, err
	}
	p1 := []string{}
	for n := 1; n < len(args); n++ {
		argv, err := conv.String(args, n, "tag", "...string")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	ret := maps.ToTag(p0, p1...)
	return ret, nil
}

// gen_INSERT
//
// syntax: INSERT(...interface {})
func gen_INSERT(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "INSERT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToInsert(p0...)
}

// gen_APPEND
//
// syntax: APPEND(...interface {})
func gen_APPEND(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "APPEND", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToAppend(p0...)
}

// gen_minHz
//
// syntax: minHz(float64)
func gen_minHz(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("minHz", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "minHz", "float64")
	if err != nil {
		return nil, err
	}
	ret := maps.ToMinHz(p0)
	return ret, nil
}

// gen_maxHz
//
// syntax: maxHz(float64)
func gen_maxHz(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("maxHz", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "maxHz", "float64")
	if err != nil {
		return nil, err
	}
	ret := maps.ToMaxHz(p0)
	return ret, nil
}

// gen_FFT
//
// syntax: FFT(, , []interface {}, ...interface {})
func gen_FFT(args ...any) (any, error) {
	if len(args) < 3 {
		return nil, conv.ErrInvalidNumOfArgs("FFT", 3, len(args))
	}
	p0, err := conv.Context(args, 0, "FFT", "*context.Context")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "FFT", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, ok := args[2].([]interface{})
	if !ok {
		return nil, conv.ErrWrongTypeOfArgs("FFT", 2, "[]interface {}", args[2])
	}
	p3 := []interface{}{}
	for n := 3; n < len(args); n++ {
		argv, err := conv.Any(args, n, "FFT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p3 = append(p3, argv)
	}
	return maps.FastFourierTransform(p0, p1, p2, p3...)
}

// gen_CSV
//
// syntax: CSV(...interface {})
func gen_CSV(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "CSV", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToCsv(p0...)
}

// gen_JSON
//
// syntax: JSON(...interface {})
func gen_JSON(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "JSON", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ToJson(p0...)
	return ret, nil
}

// gen_MARKDOWN
//
// syntax: MARKDOWN(...interface {})
func gen_MARKDOWN(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "MARKDOWN", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ToMarkdown(p0...)
	return ret, nil
}

// gen_CHART_LINE
//
// syntax: CHART_LINE(...interface {})
func gen_CHART_LINE(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "CHART_LINE", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ChartLine(p0...)
	return ret, nil
}

// gen_CHART_SCATTER
//
// syntax: CHART_SCATTER(...interface {})
func gen_CHART_SCATTER(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "CHART_SCATTER", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ChartScatter(p0...)
	return ret, nil
}

// gen_CHART_BAR
//
// syntax: CHART_BAR(...interface {})
func gen_CHART_BAR(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "CHART_BAR", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ChartBar(p0...)
	return ret, nil
}

// gen_CHART_LINE3D
//
// syntax: CHART_LINE3D(...interface {})
func gen_CHART_LINE3D(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "CHART_LINE3D", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ChartLine3D(p0...)
	return ret, nil
}

// gen_CHART_BAR3D
//
// syntax: CHART_BAR3D(...interface {})
func gen_CHART_BAR3D(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "CHART_BAR3D", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ChartBar3D(p0...)
	return ret, nil
}

// gen_CHART_SURFACE3D
//
// syntax: CHART_SURFACE3D(...interface {})
func gen_CHART_SURFACE3D(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "CHART_SURFACE3D", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ChartSurface3D(p0...)
	return ret, nil
}

// gen_CHART_SCATTER3D
//
// syntax: CHART_SCATTER3D(...interface {})
func gen_CHART_SCATTER3D(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "CHART_SCATTER3D", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := maps.ChartScatter3D(p0...)
	return ret, nil
}

// gen_separator
//
// syntax: separator(uint8)
func gen_separator(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("separator", 1, len(args))
	}
	p0, err := conv.Byte(args, 0, "separator", "uint8")
	if err != nil {
		return nil, err
	}
	ret := maps.ToSeparator(p0)
	return ret, nil
}

// gen_file
//
// syntax: file(string)
func gen_file(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("file", 1, len(args))
	}
	p0, err := conv.String(args, 0, "file", "string")
	if err != nil {
		return nil, err
	}
	return maps.ToFile(p0)
}

// gen_STRING
//
// syntax: STRING(, ...interface {})
func gen_STRING(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, conv.ErrInvalidNumOfArgs("STRING", 1, len(args))
	}
	p0, err := conv.Any(args, 0, "STRING", "interface {}")
	if err != nil {
		return nil, err
	}
	p1 := []interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := conv.Any(args, n, "STRING", "...interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	return maps.String(p0, p1...)
}

// gen_BYTES
//
// syntax: BYTES(, ...interface {})
func gen_BYTES(args ...any) (any, error) {
	if len(args) < 1 {
		return nil, conv.ErrInvalidNumOfArgs("BYTES", 1, len(args))
	}
	p0, err := conv.Any(args, 0, "BYTES", "interface {}")
	if err != nil {
		return nil, err
	}
	p1 := []interface{}{}
	for n := 1; n < len(args); n++ {
		argv, err := conv.Any(args, n, "BYTES", "...interface {}")
		if err != nil {
			return nil, err
		}
		p1 = append(p1, argv)
	}
	return maps.Bytes(p0, p1...)
}

// gen_col
//
// syntax: col(...interface {})
func gen_col(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "col", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToCol_deprecated(p0...)
}

// gen_field
//
// syntax: field(...interface {})
func gen_field(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "field", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToField(p0...)
}

// gen_header
//
// syntax: header(...interface {})
func gen_header(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "header", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToHeader(p0...)
}

// gen_datetimeType
//
// syntax: datetimeType(...interface {})
func gen_datetimeType(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "datetimeType", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToDatetimeType(p0...)
}

// gen_stringType
//
// syntax: stringType(...interface {})
func gen_stringType(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "stringType", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToStringType(p0...)
}

// gen_doubleType
//
// syntax: doubleType(...interface {})
func gen_doubleType(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "doubleType", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.ToDoubleType(p0...)
}

// gen_freq
//
// syntax: freq(float64, float64, ...float64)
func gen_freq(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, conv.ErrInvalidNumOfArgs("freq", 2, len(args))
	}
	p0, err := conv.Float64(args, 0, "freq", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Float64(args, 1, "freq", "float64")
	if err != nil {
		return nil, err
	}
	p2 := []float64{}
	for n := 2; n < len(args); n++ {
		argv, err := conv.Float64(args, n, "freq", "...float64")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := maps.ToFreq(p0, p1, p2...)
	return ret, nil
}

// gen_oscillator
//
// syntax: oscillator(...interface {})
func gen_oscillator(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "oscillator", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.Oscillator(p0...)
}

// gen_sphere
//
// syntax: sphere()
func gen_sphere(args ...any) (any, error) {
	if len(args) != 0 {
		return nil, conv.ErrInvalidNumOfArgs("sphere", 0, len(args))
	}
	ret := maps.Sphere()
	return ret, nil
}

// gen_FAKE
//
// syntax: FAKE()
func gen_FAKE(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("FAKE", 1, len(args))
	}
	p0, err := conv.Any(args, 0, "FAKE", "interface {}")
	if err != nil {
		return nil, err
	}
	return maps.Fake(p0)
}

// gen_INPUT
//
// syntax: INPUT(...interface {})
func gen_INPUT(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "INPUT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.INPUT(p0...)
}

// gen_OUTPUT
//
// syntax: OUTPUT(...interface {})
func gen_OUTPUT(args ...any) (any, error) {
	p0 := []interface{}{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Any(args, n, "OUTPUT", "...interface {}")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	return maps.OUTPUT(p0...)
}

// gen_tz
//
// syntax: tz(string)
func gen_tz(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("tz", 1, len(args))
	}
	p0, err := conv.String(args, 0, "tz", "string")
	if err != nil {
		return nil, err
	}
	return maps.TimeLocation(p0)
}

// gen_sep
//
// syntax: sep(uint8)
func gen_sep(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("sep", 1, len(args))
	}
	p0, err := conv.Byte(args, 0, "sep", "uint8")
	if err != nil {
		return nil, err
	}
	ret := maps.ToSeparator(p0)
	return ret, nil
}

// gen_assetHost
//
// syntax: assetHost(string)
func gen_assetHost(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("assetHost", 1, len(args))
	}
	p0, err := conv.String(args, 0, "assetHost", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.AssetHost(p0)
	return ret, nil
}

// gen_autoRotate
//
// syntax: autoRotate(float64)
func gen_autoRotate(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("autoRotate", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "autoRotate", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.AutoRotate(p0)
	return ret, nil
}

// gen_boxDrawBorder
//
// syntax: boxDrawBorder(bool)
func gen_boxDrawBorder(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("boxDrawBorder", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "boxDrawBorder", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.BoxDrawBorder(p0)
	return ret, nil
}

// gen_boxSeparateColumns
//
// syntax: boxSeparateColumns(bool)
func gen_boxSeparateColumns(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("boxSeparateColumns", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "boxSeparateColumns", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.BoxSeparateColumns(p0)
	return ret, nil
}

// gen_boxStyle
//
// syntax: boxStyle(string)
func gen_boxStyle(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("boxStyle", 1, len(args))
	}
	p0, err := conv.String(args, 0, "boxStyle", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.BoxStyle(p0)
	return ret, nil
}

// gen_brief
//
// syntax: brief(bool)
func gen_brief(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("brief", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "brief", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Brief(p0)
	return ret, nil
}

// gen_briefCount
//
// syntax: briefCount(int)
func gen_briefCount(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("briefCount", 1, len(args))
	}
	p0, err := conv.Int(args, 0, "briefCount", "int")
	if err != nil {
		return nil, err
	}
	ret := opts.BriefCount(p0)
	return ret, nil
}

// gen_chartJson
//
// syntax: chartJson(bool)
func gen_chartJson(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("chartJson", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "chartJson", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.ChartJson(p0)
	return ret, nil
}

// gen_columnTypes
//
// syntax: columnTypes(...string)
func gen_columnTypes(args ...any) (any, error) {
	p0 := []string{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.String(args, n, "columnTypes", "...string")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.ColumnTypes(p0...)
	return ret, nil
}

// gen_columns
//
// syntax: columns(...string)
func gen_columns(args ...any) (any, error) {
	p0 := []string{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.String(args, n, "columns", "...string")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.Columns(p0...)
	return ret, nil
}

// gen_dataZoom
//
// syntax: dataZoom(string, float32, float32)
func gen_dataZoom(args ...any) (any, error) {
	if len(args) != 3 {
		return nil, conv.ErrInvalidNumOfArgs("dataZoom", 3, len(args))
	}
	p0, err := conv.String(args, 0, "dataZoom", "string")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Float32(args, 1, "dataZoom", "float32")
	if err != nil {
		return nil, err
	}
	p2, err := conv.Float32(args, 2, "dataZoom", "float32")
	if err != nil {
		return nil, err
	}
	ret := opts.DataZoom(p0, p1, p2)
	return ret, nil
}

// gen_delimiter
//
// syntax: delimiter(string)
func gen_delimiter(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("delimiter", 1, len(args))
	}
	p0, err := conv.String(args, 0, "delimiter", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Delimiter(p0)
	return ret, nil
}

// gen_gridSize
//
// syntax: gridSize(...float64)
func gen_gridSize(args ...any) (any, error) {
	p0 := []float64{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.Float64(args, n, "gridSize", "...float64")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.GridSize(p0...)
	return ret, nil
}

// gen_heading
//
// syntax: heading(bool)
func gen_heading(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("heading", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "heading", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Heading(p0)
	return ret, nil
}

// gen_html
//
// syntax: html(bool)
func gen_html(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("html", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "html", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Html(p0)
	return ret, nil
}

// gen_inputStream
//
// syntax: inputStream(InputStream)
func gen_inputStream(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("inputStream", 1, len(args))
	}
	p0, err := conv.InputStream(args, 0, "inputStream", "spec.InputStream")
	if err != nil {
		return nil, err
	}
	ret := opts.InputStream(p0)
	return ret, nil
}

// gen_lineWidth
//
// syntax: lineWidth(float64)
func gen_lineWidth(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("lineWidth", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "lineWidth", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.LineWidth(p0)
	return ret, nil
}

// gen_markAreaNameCoord
//
// syntax: markAreaNameCoord(, , string, string, float64)
func gen_markAreaNameCoord(args ...any) (any, error) {
	if len(args) != 5 {
		return nil, conv.ErrInvalidNumOfArgs("markAreaNameCoord", 5, len(args))
	}
	p0, err := conv.Any(args, 0, "markAreaNameCoord", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Any(args, 1, "markAreaNameCoord", "interface {}")
	if err != nil {
		return nil, err
	}
	p2, err := conv.String(args, 2, "markAreaNameCoord", "string")
	if err != nil {
		return nil, err
	}
	p3, err := conv.String(args, 3, "markAreaNameCoord", "string")
	if err != nil {
		return nil, err
	}
	p4, err := conv.Float64(args, 4, "markAreaNameCoord", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.MarkAreaNameCoord(p0, p1, p2, p3, p4)
	return ret, nil
}

// gen_markLineXAxisCoord
//
// syntax: markLineXAxisCoord(, string)
func gen_markLineXAxisCoord(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("markLineXAxisCoord", 2, len(args))
	}
	p0, err := conv.Any(args, 0, "markLineXAxisCoord", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := conv.String(args, 1, "markLineXAxisCoord", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.MarkLineXAxisCoord(p0, p1)
	return ret, nil
}

// gen_markLineYAxisCoord
//
// syntax: markLineYAxisCoord(, string)
func gen_markLineYAxisCoord(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("markLineYAxisCoord", 2, len(args))
	}
	p0, err := conv.Any(args, 0, "markLineYAxisCoord", "interface {}")
	if err != nil {
		return nil, err
	}
	p1, err := conv.String(args, 1, "markLineYAxisCoord", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.MarkLineYAxisCoord(p0, p1)
	return ret, nil
}

// gen_opacity
//
// syntax: opacity(float64)
func gen_opacity(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("opacity", 1, len(args))
	}
	p0, err := conv.Float64(args, 0, "opacity", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.Opacity(p0)
	return ret, nil
}

// gen_outputStream
//
// syntax: outputStream(OutputStream)
func gen_outputStream(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("outputStream", 1, len(args))
	}
	p0, err := conv.OutputStream(args, 0, "outputStream", "spec.OutputStream")
	if err != nil {
		return nil, err
	}
	ret := opts.OutputStream(p0)
	return ret, nil
}

// gen_precision
//
// syntax: precision(int)
func gen_precision(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("precision", 1, len(args))
	}
	p0, err := conv.Int(args, 0, "precision", "int")
	if err != nil {
		return nil, err
	}
	ret := opts.Precision(p0)
	return ret, nil
}

// gen_rownum
//
// syntax: rownum(bool)
func gen_rownum(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("rownum", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "rownum", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Rownum(p0)
	return ret, nil
}

// gen_seriesLabels
//
// syntax: seriesLabels(...string)
func gen_seriesLabels(args ...any) (any, error) {
	p0 := []string{}
	for n := 0; n < len(args); n++ {
		argv, err := conv.String(args, n, "seriesLabels", "...string")
		if err != nil {
			return nil, err
		}
		p0 = append(p0, argv)
	}
	ret := opts.SeriesLabels(p0...)
	return ret, nil
}

// gen_showGrid
//
// syntax: showGrid(bool)
func gen_showGrid(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("showGrid", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "showGrid", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.ShowGrid(p0)
	return ret, nil
}

// gen_size
//
// syntax: size(string, string)
func gen_size(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("size", 2, len(args))
	}
	p0, err := conv.String(args, 0, "size", "string")
	if err != nil {
		return nil, err
	}
	p1, err := conv.String(args, 1, "size", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Size(p0, p1)
	return ret, nil
}

// gen_subtitle
//
// syntax: subtitle(string)
func gen_subtitle(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("subtitle", 1, len(args))
	}
	p0, err := conv.String(args, 0, "subtitle", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Subtitle(p0)
	return ret, nil
}

// gen_tableName
//
// syntax: tableName(string)
func gen_tableName(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("tableName", 1, len(args))
	}
	p0, err := conv.String(args, 0, "tableName", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.TableName(p0)
	return ret, nil
}

// gen_theme
//
// syntax: theme(string)
func gen_theme(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("theme", 1, len(args))
	}
	p0, err := conv.String(args, 0, "theme", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Theme(p0)
	return ret, nil
}

// gen_timeLocation
//
// syntax: timeLocation()
func gen_timeLocation(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("timeLocation", 1, len(args))
	}
	p0, err := conv.TimeLocation(args, 0, "timeLocation", "*time.Location")
	if err != nil {
		return nil, err
	}
	ret := opts.TimeLocation(p0)
	return ret, nil
}

// gen_timeformat
//
// syntax: timeformat(string)
func gen_timeformat(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("timeformat", 1, len(args))
	}
	p0, err := conv.String(args, 0, "timeformat", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Timeformat(p0)
	return ret, nil
}

// gen_title
//
// syntax: title(string)
func gen_title(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("title", 1, len(args))
	}
	p0, err := conv.String(args, 0, "title", "string")
	if err != nil {
		return nil, err
	}
	ret := opts.Title(p0)
	return ret, nil
}

// gen_transcoder
//
// syntax: transcoder(Transcoder)
func gen_transcoder(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("transcoder", 1, len(args))
	}
	p0, err := conv.Transcoder(args, 0, "transcoder", "transcoder.Transcoder")
	if err != nil {
		return nil, err
	}
	ret := opts.Transcoder(p0)
	return ret, nil
}

// gen_transpose
//
// syntax: transpose(bool)
func gen_transpose(args ...any) (any, error) {
	if len(args) != 1 {
		return nil, conv.ErrInvalidNumOfArgs("transpose", 1, len(args))
	}
	p0, err := conv.Bool(args, 0, "transpose", "bool")
	if err != nil {
		return nil, err
	}
	ret := opts.Transpose(p0)
	return ret, nil
}

// gen_visualMap
//
// syntax: visualMap(float64, float64)
func gen_visualMap(args ...any) (any, error) {
	if len(args) != 2 {
		return nil, conv.ErrInvalidNumOfArgs("visualMap", 2, len(args))
	}
	p0, err := conv.Float64(args, 0, "visualMap", "float64")
	if err != nil {
		return nil, err
	}
	p1, err := conv.Float64(args, 1, "visualMap", "float64")
	if err != nil {
		return nil, err
	}
	ret := opts.VisualMap(p0, p1)
	return ret, nil
}

// gen_xAxis
//
// syntax: xAxis(int, string, ...string)
func gen_xAxis(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, conv.ErrInvalidNumOfArgs("xAxis", 2, len(args))
	}
	p0, err := conv.Int(args, 0, "xAxis", "int")
	if err != nil {
		return nil, err
	}
	p1, err := conv.String(args, 1, "xAxis", "string")
	if err != nil {
		return nil, err
	}
	p2 := []string{}
	for n := 2; n < len(args); n++ {
		argv, err := conv.String(args, n, "xAxis", "...string")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := opts.XAxis(p0, p1, p2...)
	return ret, nil
}

// gen_yAxis
//
// syntax: yAxis(int, string, ...string)
func gen_yAxis(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, conv.ErrInvalidNumOfArgs("yAxis", 2, len(args))
	}
	p0, err := conv.Int(args, 0, "yAxis", "int")
	if err != nil {
		return nil, err
	}
	p1, err := conv.String(args, 1, "yAxis", "string")
	if err != nil {
		return nil, err
	}
	p2 := []string{}
	for n := 2; n < len(args); n++ {
		argv, err := conv.String(args, n, "yAxis", "...string")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := opts.YAxis(p0, p1, p2...)
	return ret, nil
}

// gen_zAxis
//
// syntax: zAxis(int, string, ...string)
func gen_zAxis(args ...any) (any, error) {
	if len(args) < 2 {
		return nil, conv.ErrInvalidNumOfArgs("zAxis", 2, len(args))
	}
	p0, err := conv.Int(args, 0, "zAxis", "int")
	if err != nil {
		return nil, err
	}
	p1, err := conv.String(args, 1, "zAxis", "string")
	if err != nil {
		return nil, err
	}
	p2 := []string{}
	for n := 2; n < len(args); n++ {
		argv, err := conv.String(args, n, "zAxis", "...string")
		if err != nil {
			return nil, err
		}
		p2 = append(p2, argv)
	}
	ret := opts.ZAxis(p0, p1, p2...)
	return ret, nil
}
