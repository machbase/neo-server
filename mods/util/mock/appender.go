// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/machbase/neo-spi"
	"sync"
	"time"
)

// Ensure, that AppenderMock does implement spi.Appender.
// If this is not the case, regenerate this file with moq.
var _ spi.Appender = &AppenderMock{}

// AppenderMock is a mock implementation of spi.Appender.
//
//	func TestSomethingThatUsesAppender(t *testing.T) {
//
//		// make and configure a mocked spi.Appender
//		mockedAppender := &AppenderMock{
//			AppendFunc: func(values ...any) error {
//				panic("mock out the Append method")
//			},
//			AppendWithTimestampFunc: func(ts time.Time, values ...any) error {
//				panic("mock out the AppendWithTimestamp method")
//			},
//			CloseFunc: func() (int64, int64, error) {
//				panic("mock out the Close method")
//			},
//			ColumnsFunc: func() (spi.Columns, error) {
//				panic("mock out the Columns method")
//			},
//			TableNameFunc: func() string {
//				panic("mock out the TableName method")
//			},
//			TableTypeFunc: func() spi.TableType {
//				panic("mock out the TableType method")
//			},
//		}
//
//		// use mockedAppender in code that requires spi.Appender
//		// and then make assertions.
//
//	}
type AppenderMock struct {
	// AppendFunc mocks the Append method.
	AppendFunc func(values ...any) error

	// AppendWithTimestampFunc mocks the AppendWithTimestamp method.
	AppendWithTimestampFunc func(ts time.Time, values ...any) error

	// CloseFunc mocks the Close method.
	CloseFunc func() (int64, int64, error)

	// ColumnsFunc mocks the Columns method.
	ColumnsFunc func() (spi.Columns, error)

	// TableNameFunc mocks the TableName method.
	TableNameFunc func() string

	// TableTypeFunc mocks the TableType method.
	TableTypeFunc func() spi.TableType

	// calls tracks calls to the methods.
	calls struct {
		// Append holds details about calls to the Append method.
		Append []struct {
			// Values is the values argument value.
			Values []any
		}
		// AppendWithTimestamp holds details about calls to the AppendWithTimestamp method.
		AppendWithTimestamp []struct {
			// Ts is the ts argument value.
			Ts time.Time
			// Values is the values argument value.
			Values []any
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Columns holds details about calls to the Columns method.
		Columns []struct {
		}
		// TableName holds details about calls to the TableName method.
		TableName []struct {
		}
		// TableType holds details about calls to the TableType method.
		TableType []struct {
		}
	}
	lockAppend              sync.RWMutex
	lockAppendWithTimestamp sync.RWMutex
	lockClose               sync.RWMutex
	lockColumns             sync.RWMutex
	lockTableName           sync.RWMutex
	lockTableType           sync.RWMutex
}

// Append calls AppendFunc.
func (mock *AppenderMock) Append(values ...any) error {
	if mock.AppendFunc == nil {
		panic("AppenderMock.AppendFunc: method is nil but Appender.Append was just called")
	}
	callInfo := struct {
		Values []any
	}{
		Values: values,
	}
	mock.lockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	mock.lockAppend.Unlock()
	return mock.AppendFunc(values...)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//
//	len(mockedAppender.AppendCalls())
func (mock *AppenderMock) AppendCalls() []struct {
	Values []any
} {
	var calls []struct {
		Values []any
	}
	mock.lockAppend.RLock()
	calls = mock.calls.Append
	mock.lockAppend.RUnlock()
	return calls
}

// AppendWithTimestamp calls AppendWithTimestampFunc.
func (mock *AppenderMock) AppendWithTimestamp(ts time.Time, values ...any) error {
	if mock.AppendWithTimestampFunc == nil {
		panic("AppenderMock.AppendWithTimestampFunc: method is nil but Appender.AppendWithTimestamp was just called")
	}
	callInfo := struct {
		Ts     time.Time
		Values []any
	}{
		Ts:     ts,
		Values: values,
	}
	mock.lockAppendWithTimestamp.Lock()
	mock.calls.AppendWithTimestamp = append(mock.calls.AppendWithTimestamp, callInfo)
	mock.lockAppendWithTimestamp.Unlock()
	return mock.AppendWithTimestampFunc(ts, values...)
}

// AppendWithTimestampCalls gets all the calls that were made to AppendWithTimestamp.
// Check the length with:
//
//	len(mockedAppender.AppendWithTimestampCalls())
func (mock *AppenderMock) AppendWithTimestampCalls() []struct {
	Ts     time.Time
	Values []any
} {
	var calls []struct {
		Ts     time.Time
		Values []any
	}
	mock.lockAppendWithTimestamp.RLock()
	calls = mock.calls.AppendWithTimestamp
	mock.lockAppendWithTimestamp.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *AppenderMock) Close() (int64, int64, error) {
	if mock.CloseFunc == nil {
		panic("AppenderMock.CloseFunc: method is nil but Appender.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedAppender.CloseCalls())
func (mock *AppenderMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Columns calls ColumnsFunc.
func (mock *AppenderMock) Columns() (spi.Columns, error) {
	if mock.ColumnsFunc == nil {
		panic("AppenderMock.ColumnsFunc: method is nil but Appender.Columns was just called")
	}
	callInfo := struct {
	}{}
	mock.lockColumns.Lock()
	mock.calls.Columns = append(mock.calls.Columns, callInfo)
	mock.lockColumns.Unlock()
	return mock.ColumnsFunc()
}

// ColumnsCalls gets all the calls that were made to Columns.
// Check the length with:
//
//	len(mockedAppender.ColumnsCalls())
func (mock *AppenderMock) ColumnsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockColumns.RLock()
	calls = mock.calls.Columns
	mock.lockColumns.RUnlock()
	return calls
}

// TableName calls TableNameFunc.
func (mock *AppenderMock) TableName() string {
	if mock.TableNameFunc == nil {
		panic("AppenderMock.TableNameFunc: method is nil but Appender.TableName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTableName.Lock()
	mock.calls.TableName = append(mock.calls.TableName, callInfo)
	mock.lockTableName.Unlock()
	return mock.TableNameFunc()
}

// TableNameCalls gets all the calls that were made to TableName.
// Check the length with:
//
//	len(mockedAppender.TableNameCalls())
func (mock *AppenderMock) TableNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTableName.RLock()
	calls = mock.calls.TableName
	mock.lockTableName.RUnlock()
	return calls
}

// TableType calls TableTypeFunc.
func (mock *AppenderMock) TableType() spi.TableType {
	if mock.TableTypeFunc == nil {
		panic("AppenderMock.TableTypeFunc: method is nil but Appender.TableType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTableType.Lock()
	mock.calls.TableType = append(mock.calls.TableType, callInfo)
	mock.lockTableType.Unlock()
	return mock.TableTypeFunc()
}

// TableTypeCalls gets all the calls that were made to TableType.
// Check the length with:
//
//	len(mockedAppender.TableTypeCalls())
func (mock *AppenderMock) TableTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTableType.RLock()
	calls = mock.calls.TableType
	mock.lockTableType.RUnlock()
	return calls
}
