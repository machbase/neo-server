// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mock

import (
	"github.com/machbase/neo-spi"
	"sync"
)

// Ensure, that RowsMock does implement spi.Rows.
// If this is not the case, regenerate this file with moq.
var _ spi.Rows = &RowsMock{}

// RowsMock is a mock implementation of spi.Rows.
//
//	func TestSomethingThatUsesRows(t *testing.T) {
//
//		// make and configure a mocked spi.Rows
//		mockedRows := &RowsMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ColumnsFunc: func() (spi.Columns, error) {
//				panic("mock out the Columns method")
//			},
//			IsFetchableFunc: func() bool {
//				panic("mock out the IsFetchable method")
//			},
//			MessageFunc: func() string {
//				panic("mock out the Message method")
//			},
//			NextFunc: func() bool {
//				panic("mock out the Next method")
//			},
//			RowsAffectedFunc: func() int64 {
//				panic("mock out the RowsAffected method")
//			},
//			ScanFunc: func(cols ...any) error {
//				panic("mock out the Scan method")
//			},
//		}
//
//		// use mockedRows in code that requires spi.Rows
//		// and then make assertions.
//
//	}
type RowsMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ColumnsFunc mocks the Columns method.
	ColumnsFunc func() (spi.Columns, error)

	// IsFetchableFunc mocks the IsFetchable method.
	IsFetchableFunc func() bool

	// MessageFunc mocks the Message method.
	MessageFunc func() string

	// NextFunc mocks the Next method.
	NextFunc func() bool

	// RowsAffectedFunc mocks the RowsAffected method.
	RowsAffectedFunc func() int64

	// ScanFunc mocks the Scan method.
	ScanFunc func(cols ...any) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Columns holds details about calls to the Columns method.
		Columns []struct {
		}
		// IsFetchable holds details about calls to the IsFetchable method.
		IsFetchable []struct {
		}
		// Message holds details about calls to the Message method.
		Message []struct {
		}
		// Next holds details about calls to the Next method.
		Next []struct {
		}
		// RowsAffected holds details about calls to the RowsAffected method.
		RowsAffected []struct {
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Cols is the cols argument value.
			Cols []any
		}
	}
	lockClose        sync.RWMutex
	lockColumns      sync.RWMutex
	lockIsFetchable  sync.RWMutex
	lockMessage      sync.RWMutex
	lockNext         sync.RWMutex
	lockRowsAffected sync.RWMutex
	lockScan         sync.RWMutex
}

// Close calls CloseFunc.
func (mock *RowsMock) Close() error {
	if mock.CloseFunc == nil {
		panic("RowsMock.CloseFunc: method is nil but Rows.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedRows.CloseCalls())
func (mock *RowsMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Columns calls ColumnsFunc.
func (mock *RowsMock) Columns() (spi.Columns, error) {
	if mock.ColumnsFunc == nil {
		panic("RowsMock.ColumnsFunc: method is nil but Rows.Columns was just called")
	}
	callInfo := struct {
	}{}
	mock.lockColumns.Lock()
	mock.calls.Columns = append(mock.calls.Columns, callInfo)
	mock.lockColumns.Unlock()
	return mock.ColumnsFunc()
}

// ColumnsCalls gets all the calls that were made to Columns.
// Check the length with:
//
//	len(mockedRows.ColumnsCalls())
func (mock *RowsMock) ColumnsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockColumns.RLock()
	calls = mock.calls.Columns
	mock.lockColumns.RUnlock()
	return calls
}

// IsFetchable calls IsFetchableFunc.
func (mock *RowsMock) IsFetchable() bool {
	if mock.IsFetchableFunc == nil {
		panic("RowsMock.IsFetchableFunc: method is nil but Rows.IsFetchable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsFetchable.Lock()
	mock.calls.IsFetchable = append(mock.calls.IsFetchable, callInfo)
	mock.lockIsFetchable.Unlock()
	return mock.IsFetchableFunc()
}

// IsFetchableCalls gets all the calls that were made to IsFetchable.
// Check the length with:
//
//	len(mockedRows.IsFetchableCalls())
func (mock *RowsMock) IsFetchableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsFetchable.RLock()
	calls = mock.calls.IsFetchable
	mock.lockIsFetchable.RUnlock()
	return calls
}

// Message calls MessageFunc.
func (mock *RowsMock) Message() string {
	if mock.MessageFunc == nil {
		panic("RowsMock.MessageFunc: method is nil but Rows.Message was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMessage.Lock()
	mock.calls.Message = append(mock.calls.Message, callInfo)
	mock.lockMessage.Unlock()
	return mock.MessageFunc()
}

// MessageCalls gets all the calls that were made to Message.
// Check the length with:
//
//	len(mockedRows.MessageCalls())
func (mock *RowsMock) MessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMessage.RLock()
	calls = mock.calls.Message
	mock.lockMessage.RUnlock()
	return calls
}

// Next calls NextFunc.
func (mock *RowsMock) Next() bool {
	if mock.NextFunc == nil {
		panic("RowsMock.NextFunc: method is nil but Rows.Next was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNext.Lock()
	mock.calls.Next = append(mock.calls.Next, callInfo)
	mock.lockNext.Unlock()
	return mock.NextFunc()
}

// NextCalls gets all the calls that were made to Next.
// Check the length with:
//
//	len(mockedRows.NextCalls())
func (mock *RowsMock) NextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNext.RLock()
	calls = mock.calls.Next
	mock.lockNext.RUnlock()
	return calls
}

// RowsAffected calls RowsAffectedFunc.
func (mock *RowsMock) RowsAffected() int64 {
	if mock.RowsAffectedFunc == nil {
		panic("RowsMock.RowsAffectedFunc: method is nil but Rows.RowsAffected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRowsAffected.Lock()
	mock.calls.RowsAffected = append(mock.calls.RowsAffected, callInfo)
	mock.lockRowsAffected.Unlock()
	return mock.RowsAffectedFunc()
}

// RowsAffectedCalls gets all the calls that were made to RowsAffected.
// Check the length with:
//
//	len(mockedRows.RowsAffectedCalls())
func (mock *RowsMock) RowsAffectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRowsAffected.RLock()
	calls = mock.calls.RowsAffected
	mock.lockRowsAffected.RUnlock()
	return calls
}

// Scan calls ScanFunc.
func (mock *RowsMock) Scan(cols ...any) error {
	if mock.ScanFunc == nil {
		panic("RowsMock.ScanFunc: method is nil but Rows.Scan was just called")
	}
	callInfo := struct {
		Cols []any
	}{
		Cols: cols,
	}
	mock.lockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	mock.lockScan.Unlock()
	return mock.ScanFunc(cols...)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//
//	len(mockedRows.ScanCalls())
func (mock *RowsMock) ScanCalls() []struct {
	Cols []any
} {
	var calls []struct {
		Cols []any
	}
	mock.lockScan.RLock()
	calls = mock.calls.Scan
	mock.lockScan.RUnlock()
	return calls
}
