<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ .Localize "Log Viewer"}}</title>

    <style>
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            box-sizing: border-box;
        }

        body {
            background-color: #0d1117;
            color: white;
            font-family: {{.Terminal.FontFamily}};
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #container {
            height: calc(100vh - 20px);
            width: calc(100vw - 20px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 10px;
        }

        #filter-bar {
            display: flex;
            gap: 8px;
            padding: 10px;
            background-color: #1e1e1e;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            align-items: center;
        }

        .logtype-select-container {
            position: relative;
            min-width: 180px;
        }

        .logtype-select-button {
            padding: 8px 12px;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            color: white;
            font-family: '{{.ControlBar.FontFamily}}';
            font-size: {{.ControlBar.FontSize}}px;
            cursor: pointer;
            width: 100%;
            text-align: left;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s;
        }

        #logtype-select-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
            margin-right: 8px;
        }

        .logtype-select-button:hover {
            background-color: #3d3d3d;
        }

        .logtype-select-button:focus {
            outline: none;
            border-color: #0078d4;
        }

        .logtype-select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 4px;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            display: none;
            max-height: 250px;
            overflow-y: auto;
        }

        .logtype-select-dropdown.open {
            display: block;
        }

        .logtype-option {
            padding: 10px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: background-color 0.2s;
        }

        .logtype-option:hover {
            background-color: #3d3d3d;
        }

        .logtype-option input[type="checkbox"] {
            cursor: pointer;
            width: calc({{.ControlBar.FontSize}}px + 2px);
            height: calc({{.ControlBar.FontSize}}px + 2px);
        }

        .logtype-option label {
            cursor: pointer;
            flex: 1;
            font-size: {{.ControlBar.FontSize}}px;
        }

        .arrow-down {
            border: solid white;
            border-width: 0 2px 2px 0;
            display: inline-block;
            padding: 3px;
            transform: rotate(45deg);
            -webkit-transform: rotate(45deg);
            transition: transform 0.2s;
        }

        .arrow-down.open {
            transform: rotate(-135deg);
            -webkit-transform: rotate(-135deg);
        }

        #filter-input {
            flex: 1;
            padding: 8px 12px;
            background-color: #2d2d2d;
            border: 1px solid #444;
            border-radius: 6px;
            color: white;
            font-family: '{{.ControlBar.FontFamily}}';
            font-size: {{.ControlBar.FontSize}}px;
        }

        #filter-input:focus {
            outline: none;
            border-color: #0078d4;
        }

        .filter-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-family: '{{.ControlBar.FontFamily}}';
            font-size: {{.ControlBar.FontSize}}px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #apply-btn {
            background-color: #0078d4;
            color: white;
        }

        #apply-btn:hover {
            background-color: #005a9e;
        }

        #clear-btn {
            background-color: #444;
            color: white;
        }

        #clear-btn:hover {
            background-color: #555;
        }

        #terminal {
            flex: 1;
            min-height: 0;
            padding: 8px;
            background-color: {{.Terminal.Theme.Background}};
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            user-select: none;
            /* Disable text selection */
            -ms-user-select: none;
            /* IE 10+ */
            -moz-user-select: none;
            /* Firefox */
            -webkit-user-select: none;
            /* Safari */
        }
    </style>
</head>

<body>
    <!-- Container for filter bar and terminal -->
    <div id="container">
        <!-- Filter bar -->
        {{ if not .ControlBar.Hide }}
        <div id="filter-bar">
            <!-- Log Multi-Select -->
            {{if gt (len .Files) 1 }}
            <div class="logtype-select-container">
                <button class="logtype-select-button" id="logtype-select-btn">
                    <span id="logtype-select-text">{{ .Localize "All Logs" }}</span>
                    <span class="arrow-down" id="logtype-arrow"></span>
                </button>
                <div class="logtype-select-dropdown" id="logtype-dropdown">
                    {{ range $name := .Files }}
                    <div class="logtype-option">
                        <input type="checkbox" id="logtype-{{$name}}" value="{{$name}}" checked>
                        <label for="logtype-{{$name}}">{{$name}}</label>
                    </div>
                    {{ end }}
                </div>
            </div>
            {{end}}
            <input type="text" id="filter-input" placeholder="{{ .Localize "Enter filter text..."}}" />
            <button id="apply-btn" class="filter-btn">{{ .Localize "Apply"}}</button>
            <button id="clear-btn" class="filter-btn">{{ .Localize "Clear"}}</button>
        </div>
        {{ end }}

        <!-- Terminal container -->
        <div id="terminal"></div>
    </div>

    <!-- Xterm.js CSS -->
    <link rel="stylesheet" href="xterm.css" />
    <!-- Xterm.js JS -->
    <script src="xterm.js"></script>
    <script src="addon-fit.min.js"></script>
    <!-- <script src="addon-attach.min.js"></script> -->
    <script src="addon-webgl.min.js"></script>

    <script>
        // Create a new terminal instance
        const term = new Terminal({{ .Terminal }});

        // Create fit addon instance
        const fitAddon = new window.FitAddon.FitAddon();
        const webglAddon = new window.WebglAddon.WebglAddon();

        // Load addon into terminal
        term.loadAddon(fitAddon);
        term.loadAddon(webglAddon);

        // Attach terminal to the DOM
        term.open(document.getElementById('terminal'));

        // Fit terminal to container
        fitAddon.fit();

        // Refit on window resize with debounce
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                fitAddon.fit();
            }, 100);
        });

        // Auto-scroll management
        let autoScroll = true;
        let lastScrollTop = 0;

        // Monitor user scrolling to disable/enable auto-scroll
        term.element.querySelector('.xterm-viewport').addEventListener('scroll', (e) => {
            const viewport = e.target;
            const scrollTop = viewport.scrollTop;
            const scrollHeight = viewport.scrollHeight;
            const clientHeight = viewport.clientHeight;
            
            // Check if user scrolled to the bottom (with small threshold)
            const isAtBottom = Math.abs(scrollHeight - scrollTop - clientHeight) < 5;
            
            // Enable auto-scroll when user manually scrolls to bottom
            if (isAtBottom) {
                autoScroll = true;
            } 
            // Disable auto-scroll when user scrolls up
            else if (scrollTop < lastScrollTop) {
                autoScroll = false;
            }
            
            lastScrollTop = scrollTop;
        });

        // Function to scroll to bottom
        function scrollToBottom() {
            if (autoScroll) {
                term.scrollToBottom();
            }
        }

        // SSE connection management
        let eventSource = null;
        let currentFilter = '';

        function connectSSE(filter = '', selectedLogTypes = []) {
            // Close existing connection if any
            if (eventSource) {
                eventSource.close();
            }

            // Clear terminal
            term.clear();

            // Build URL with filter and selected parameters
            let url = './watch.stream';
            const params = new URLSearchParams();
            
            if (filter) {
                params.append('filter', filter);
            }
            
            if (selectedLogTypes.length > 0) {
                selectedLogTypes.forEach(type => {
                    params.append('file', type);
                });
            }
            
            if (params.toString()) {
                url += '?' + params.toString();
            }
            
            currentFilter = filter;

            // Connect to SSE endpoint
            eventSource = new EventSource(url);
            
            eventSource.onopen = () => {
                let msg = 'Connected to log stream';
                if (selectedLogTypes.length > 0) {
                    msg += ` (files: ${selectedLogTypes.join(', ')})`;
                }
                if (filter) {
                    msg += ` (filter: "${filter}")`;
                }
                term.writeln(`\x1b[32m${msg}...\x1b[0m`);
                term.writeln('');
            };

            eventSource.onmessage = (event) => {
                // Write each log line to terminal
                term.writeln(event.data);
                // Auto-scroll to bottom if enabled
                scrollToBottom();
            };

            eventSource.onerror = (error) => {
                term.writeln('\x1b[31mConnection error. Retrying...\x1b[0m');
                console.error('SSE Error:', error);
            };
        }

        // Log type select dropdown controls
        const logtypeSelectBtn = document.getElementById('logtype-select-btn');
        const logtypeDropdown = document.getElementById('logtype-dropdown');
        const logtypeSelectText = document.getElementById('logtype-select-text');
        const logtypeArrow = document.getElementById('logtype-arrow');
        const logtypeCheckboxes = document.querySelectorAll('.logtype-option input[type="checkbox"]');

        // Toggle dropdown
        if( logtypeSelectBtn ) {
            logtypeSelectBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                logtypeDropdown.classList.toggle('open');
                logtypeArrow.classList.toggle('open');
            });
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!logtypeSelectBtn.contains(e.target) && !logtypeDropdown.contains(e.target)) {
                logtypeDropdown.classList.remove('open');
                logtypeArrow.classList.remove('open');
            }
        });

        // Update button text when checkboxes change
        function updateLogtypeSelectText() {
            const selected = Array.from(logtypeCheckboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);
            
            if (selected.length === 0) {
                logtypeSelectText.textContent = '{{ .Localize "No Logs"}}';
            } else if (selected.length === logtypeCheckboxes.length) {
                logtypeSelectText.textContent = '{{ .Localize "All Logs" }}';
            } else {
                logtypeSelectText.textContent = selected.join(', ');
            }
        }

        logtypeCheckboxes.forEach(checkbox => {
            checkbox.addEventListener('change', updateLogtypeSelectText);
        });

        // Get selected log types
        function getSelectedLogTypes() {
            return Array.from(logtypeCheckboxes)
                .filter(cb => cb.checked)
                .map(cb => cb.value);
        }

        // Initial connection without filter
        connectSSE('', getSelectedLogTypes());

        // Filter controls
        const filterInput = document.getElementById('filter-input');
        const applyBtn = document.getElementById('apply-btn');
        const clearBtn = document.getElementById('clear-btn');

        applyBtn.addEventListener('click', () => {
            const filter = filterInput.value.trim();
            const selected = getSelectedLogTypes();
            connectSSE(filter, selected);
        });

        clearBtn.addEventListener('click', () => {
            filterInput.value = '';
            // Reset all checkboxes to checked
            logtypeCheckboxes.forEach(cb => cb.checked = true);
            updateLogtypeSelectText();
            connectSSE('', getSelectedLogTypes());
        });

        // Allow Enter key to apply filter
        filterInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const filter = filterInput.value.trim();
                const selected = getSelectedLogTypes();
                connectSSE(filter, selected);
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (eventSource) {
                eventSource.close();
            }
        });
    </script>
</body>

</html>