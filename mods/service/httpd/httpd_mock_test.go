// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package httpd

import (
	"context"
	"github.com/machbase/neo-spi"
	"sync"
	"time"
)

// Ensure, that DatabaseMock does implement spi.Database.
// If this is not the case, regenerate this file with moq.
var _ spi.Database = &DatabaseMock{}

// DatabaseMock is a mock implementation of spi.Database.
//
//	func TestSomethingThatUsesDatabase(t *testing.T) {
//
//		// make and configure a mocked spi.Database
//		mockedDatabase := &DatabaseMock{
//			AppenderFunc: func(tableName string, opts ...spi.AppendOption) (spi.Appender, error) {
//				panic("mock out the Appender method")
//			},
//			ExecFunc: func(sqlText string, params ...any) spi.Result {
//				panic("mock out the Exec method")
//			},
//			ExecContextFunc: func(ctx context.Context, sqlText string, params ...any) spi.Result {
//				panic("mock out the ExecContext method")
//			},
//			QueryFunc: func(sqlText string, params ...any) (spi.Rows, error) {
//				panic("mock out the Query method")
//			},
//			QueryContextFunc: func(ctx context.Context, sqlText string, params ...any) (spi.Rows, error) {
//				panic("mock out the QueryContext method")
//			},
//			QueryRowFunc: func(sqlText string, params ...any) spi.Row {
//				panic("mock out the QueryRow method")
//			},
//			QueryRowContextFunc: func(ctx context.Context, sqlText string, params ...any) spi.Row {
//				panic("mock out the QueryRowContext method")
//			},
//		}
//
//		// use mockedDatabase in code that requires spi.Database
//		// and then make assertions.
//
//	}
type DatabaseMock struct {
	// AppenderFunc mocks the Appender method.
	AppenderFunc func(tableName string, opts ...spi.AppendOption) (spi.Appender, error)

	// ExecFunc mocks the Exec method.
	ExecFunc func(sqlText string, params ...any) spi.Result

	// ExecContextFunc mocks the ExecContext method.
	ExecContextFunc func(ctx context.Context, sqlText string, params ...any) spi.Result

	// QueryFunc mocks the Query method.
	QueryFunc func(sqlText string, params ...any) (spi.Rows, error)

	// QueryContextFunc mocks the QueryContext method.
	QueryContextFunc func(ctx context.Context, sqlText string, params ...any) (spi.Rows, error)

	// QueryRowFunc mocks the QueryRow method.
	QueryRowFunc func(sqlText string, params ...any) spi.Row

	// QueryRowContextFunc mocks the QueryRowContext method.
	QueryRowContextFunc func(ctx context.Context, sqlText string, params ...any) spi.Row

	// calls tracks calls to the methods.
	calls struct {
		// Appender holds details about calls to the Appender method.
		Appender []struct {
			// TableName is the tableName argument value.
			TableName string
			// Opts is the opts argument value.
			Opts []spi.AppendOption
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// ExecContext holds details about calls to the ExecContext method.
		ExecContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// Query holds details about calls to the Query method.
		Query []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryContext holds details about calls to the QueryContext method.
		QueryContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryRow holds details about calls to the QueryRow method.
		QueryRow []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryRowContext holds details about calls to the QueryRowContext method.
		QueryRowContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
	}
	lockAppender        sync.RWMutex
	lockExec            sync.RWMutex
	lockExecContext     sync.RWMutex
	lockQuery           sync.RWMutex
	lockQueryContext    sync.RWMutex
	lockQueryRow        sync.RWMutex
	lockQueryRowContext sync.RWMutex
}

// Appender calls AppenderFunc.
func (mock *DatabaseMock) Appender(tableName string, opts ...spi.AppendOption) (spi.Appender, error) {
	if mock.AppenderFunc == nil {
		panic("DatabaseMock.AppenderFunc: method is nil but Database.Appender was just called")
	}
	callInfo := struct {
		TableName string
		Opts      []spi.AppendOption
	}{
		TableName: tableName,
		Opts:      opts,
	}
	mock.lockAppender.Lock()
	mock.calls.Appender = append(mock.calls.Appender, callInfo)
	mock.lockAppender.Unlock()
	return mock.AppenderFunc(tableName, opts...)
}

// AppenderCalls gets all the calls that were made to Appender.
// Check the length with:
//
//	len(mockedDatabase.AppenderCalls())
func (mock *DatabaseMock) AppenderCalls() []struct {
	TableName string
	Opts      []spi.AppendOption
} {
	var calls []struct {
		TableName string
		Opts      []spi.AppendOption
	}
	mock.lockAppender.RLock()
	calls = mock.calls.Appender
	mock.lockAppender.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *DatabaseMock) Exec(sqlText string, params ...any) spi.Result {
	if mock.ExecFunc == nil {
		panic("DatabaseMock.ExecFunc: method is nil but Database.Exec was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(sqlText, params...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedDatabase.ExecCalls())
func (mock *DatabaseMock) ExecCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// ExecContext calls ExecContextFunc.
func (mock *DatabaseMock) ExecContext(ctx context.Context, sqlText string, params ...any) spi.Result {
	if mock.ExecContextFunc == nil {
		panic("DatabaseMock.ExecContextFunc: method is nil but Database.ExecContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockExecContext.Lock()
	mock.calls.ExecContext = append(mock.calls.ExecContext, callInfo)
	mock.lockExecContext.Unlock()
	return mock.ExecContextFunc(ctx, sqlText, params...)
}

// ExecContextCalls gets all the calls that were made to ExecContext.
// Check the length with:
//
//	len(mockedDatabase.ExecContextCalls())
func (mock *DatabaseMock) ExecContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockExecContext.RLock()
	calls = mock.calls.ExecContext
	mock.lockExecContext.RUnlock()
	return calls
}

// Query calls QueryFunc.
func (mock *DatabaseMock) Query(sqlText string, params ...any) (spi.Rows, error) {
	if mock.QueryFunc == nil {
		panic("DatabaseMock.QueryFunc: method is nil but Database.Query was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(sqlText, params...)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedDatabase.QueryCalls())
func (mock *DatabaseMock) QueryCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// QueryContext calls QueryContextFunc.
func (mock *DatabaseMock) QueryContext(ctx context.Context, sqlText string, params ...any) (spi.Rows, error) {
	if mock.QueryContextFunc == nil {
		panic("DatabaseMock.QueryContextFunc: method is nil but Database.QueryContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryContext.Lock()
	mock.calls.QueryContext = append(mock.calls.QueryContext, callInfo)
	mock.lockQueryContext.Unlock()
	return mock.QueryContextFunc(ctx, sqlText, params...)
}

// QueryContextCalls gets all the calls that were made to QueryContext.
// Check the length with:
//
//	len(mockedDatabase.QueryContextCalls())
func (mock *DatabaseMock) QueryContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockQueryContext.RLock()
	calls = mock.calls.QueryContext
	mock.lockQueryContext.RUnlock()
	return calls
}

// QueryRow calls QueryRowFunc.
func (mock *DatabaseMock) QueryRow(sqlText string, params ...any) spi.Row {
	if mock.QueryRowFunc == nil {
		panic("DatabaseMock.QueryRowFunc: method is nil but Database.QueryRow was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryRow.Lock()
	mock.calls.QueryRow = append(mock.calls.QueryRow, callInfo)
	mock.lockQueryRow.Unlock()
	return mock.QueryRowFunc(sqlText, params...)
}

// QueryRowCalls gets all the calls that were made to QueryRow.
// Check the length with:
//
//	len(mockedDatabase.QueryRowCalls())
func (mock *DatabaseMock) QueryRowCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockQueryRow.RLock()
	calls = mock.calls.QueryRow
	mock.lockQueryRow.RUnlock()
	return calls
}

// QueryRowContext calls QueryRowContextFunc.
func (mock *DatabaseMock) QueryRowContext(ctx context.Context, sqlText string, params ...any) spi.Row {
	if mock.QueryRowContextFunc == nil {
		panic("DatabaseMock.QueryRowContextFunc: method is nil but Database.QueryRowContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryRowContext.Lock()
	mock.calls.QueryRowContext = append(mock.calls.QueryRowContext, callInfo)
	mock.lockQueryRowContext.Unlock()
	return mock.QueryRowContextFunc(ctx, sqlText, params...)
}

// QueryRowContextCalls gets all the calls that were made to QueryRowContext.
// Check the length with:
//
//	len(mockedDatabase.QueryRowContextCalls())
func (mock *DatabaseMock) QueryRowContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockQueryRowContext.RLock()
	calls = mock.calls.QueryRowContext
	mock.lockQueryRowContext.RUnlock()
	return calls
}

// Ensure, that DatabaseServerMock does implement spi.DatabaseServer.
// If this is not the case, regenerate this file with moq.
var _ spi.DatabaseServer = &DatabaseServerMock{}

// DatabaseServerMock is a mock implementation of spi.DatabaseServer.
//
//	func TestSomethingThatUsesDatabaseServer(t *testing.T) {
//
//		// make and configure a mocked spi.DatabaseServer
//		mockedDatabaseServer := &DatabaseServerMock{
//			AppenderFunc: func(tableName string, opts ...spi.AppendOption) (spi.Appender, error) {
//				panic("mock out the Appender method")
//			},
//			ExecFunc: func(sqlText string, params ...any) spi.Result {
//				panic("mock out the Exec method")
//			},
//			ExecContextFunc: func(ctx context.Context, sqlText string, params ...any) spi.Result {
//				panic("mock out the ExecContext method")
//			},
//			QueryFunc: func(sqlText string, params ...any) (spi.Rows, error) {
//				panic("mock out the Query method")
//			},
//			QueryContextFunc: func(ctx context.Context, sqlText string, params ...any) (spi.Rows, error) {
//				panic("mock out the QueryContext method")
//			},
//			QueryRowFunc: func(sqlText string, params ...any) spi.Row {
//				panic("mock out the QueryRow method")
//			},
//			QueryRowContextFunc: func(ctx context.Context, sqlText string, params ...any) spi.Row {
//				panic("mock out the QueryRowContext method")
//			},
//			ShutdownFunc: func() error {
//				panic("mock out the Shutdown method")
//			},
//			StartupFunc: func() error {
//				panic("mock out the Startup method")
//			},
//		}
//
//		// use mockedDatabaseServer in code that requires spi.DatabaseServer
//		// and then make assertions.
//
//	}
type DatabaseServerMock struct {
	// AppenderFunc mocks the Appender method.
	AppenderFunc func(tableName string, opts ...spi.AppendOption) (spi.Appender, error)

	// ExecFunc mocks the Exec method.
	ExecFunc func(sqlText string, params ...any) spi.Result

	// ExecContextFunc mocks the ExecContext method.
	ExecContextFunc func(ctx context.Context, sqlText string, params ...any) spi.Result

	// QueryFunc mocks the Query method.
	QueryFunc func(sqlText string, params ...any) (spi.Rows, error)

	// QueryContextFunc mocks the QueryContext method.
	QueryContextFunc func(ctx context.Context, sqlText string, params ...any) (spi.Rows, error)

	// QueryRowFunc mocks the QueryRow method.
	QueryRowFunc func(sqlText string, params ...any) spi.Row

	// QueryRowContextFunc mocks the QueryRowContext method.
	QueryRowContextFunc func(ctx context.Context, sqlText string, params ...any) spi.Row

	// ShutdownFunc mocks the Shutdown method.
	ShutdownFunc func() error

	// StartupFunc mocks the Startup method.
	StartupFunc func() error

	// calls tracks calls to the methods.
	calls struct {
		// Appender holds details about calls to the Appender method.
		Appender []struct {
			// TableName is the tableName argument value.
			TableName string
			// Opts is the opts argument value.
			Opts []spi.AppendOption
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// ExecContext holds details about calls to the ExecContext method.
		ExecContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// Query holds details about calls to the Query method.
		Query []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryContext holds details about calls to the QueryContext method.
		QueryContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryRow holds details about calls to the QueryRow method.
		QueryRow []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryRowContext holds details about calls to the QueryRowContext method.
		QueryRowContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// Shutdown holds details about calls to the Shutdown method.
		Shutdown []struct {
		}
		// Startup holds details about calls to the Startup method.
		Startup []struct {
		}
	}
	lockAppender        sync.RWMutex
	lockExec            sync.RWMutex
	lockExecContext     sync.RWMutex
	lockQuery           sync.RWMutex
	lockQueryContext    sync.RWMutex
	lockQueryRow        sync.RWMutex
	lockQueryRowContext sync.RWMutex
	lockShutdown        sync.RWMutex
	lockStartup         sync.RWMutex
}

// Appender calls AppenderFunc.
func (mock *DatabaseServerMock) Appender(tableName string, opts ...spi.AppendOption) (spi.Appender, error) {
	if mock.AppenderFunc == nil {
		panic("DatabaseServerMock.AppenderFunc: method is nil but DatabaseServer.Appender was just called")
	}
	callInfo := struct {
		TableName string
		Opts      []spi.AppendOption
	}{
		TableName: tableName,
		Opts:      opts,
	}
	mock.lockAppender.Lock()
	mock.calls.Appender = append(mock.calls.Appender, callInfo)
	mock.lockAppender.Unlock()
	return mock.AppenderFunc(tableName, opts...)
}

// AppenderCalls gets all the calls that were made to Appender.
// Check the length with:
//
//	len(mockedDatabaseServer.AppenderCalls())
func (mock *DatabaseServerMock) AppenderCalls() []struct {
	TableName string
	Opts      []spi.AppendOption
} {
	var calls []struct {
		TableName string
		Opts      []spi.AppendOption
	}
	mock.lockAppender.RLock()
	calls = mock.calls.Appender
	mock.lockAppender.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *DatabaseServerMock) Exec(sqlText string, params ...any) spi.Result {
	if mock.ExecFunc == nil {
		panic("DatabaseServerMock.ExecFunc: method is nil but DatabaseServer.Exec was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(sqlText, params...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedDatabaseServer.ExecCalls())
func (mock *DatabaseServerMock) ExecCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// ExecContext calls ExecContextFunc.
func (mock *DatabaseServerMock) ExecContext(ctx context.Context, sqlText string, params ...any) spi.Result {
	if mock.ExecContextFunc == nil {
		panic("DatabaseServerMock.ExecContextFunc: method is nil but DatabaseServer.ExecContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockExecContext.Lock()
	mock.calls.ExecContext = append(mock.calls.ExecContext, callInfo)
	mock.lockExecContext.Unlock()
	return mock.ExecContextFunc(ctx, sqlText, params...)
}

// ExecContextCalls gets all the calls that were made to ExecContext.
// Check the length with:
//
//	len(mockedDatabaseServer.ExecContextCalls())
func (mock *DatabaseServerMock) ExecContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockExecContext.RLock()
	calls = mock.calls.ExecContext
	mock.lockExecContext.RUnlock()
	return calls
}

// Query calls QueryFunc.
func (mock *DatabaseServerMock) Query(sqlText string, params ...any) (spi.Rows, error) {
	if mock.QueryFunc == nil {
		panic("DatabaseServerMock.QueryFunc: method is nil but DatabaseServer.Query was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(sqlText, params...)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedDatabaseServer.QueryCalls())
func (mock *DatabaseServerMock) QueryCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// QueryContext calls QueryContextFunc.
func (mock *DatabaseServerMock) QueryContext(ctx context.Context, sqlText string, params ...any) (spi.Rows, error) {
	if mock.QueryContextFunc == nil {
		panic("DatabaseServerMock.QueryContextFunc: method is nil but DatabaseServer.QueryContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryContext.Lock()
	mock.calls.QueryContext = append(mock.calls.QueryContext, callInfo)
	mock.lockQueryContext.Unlock()
	return mock.QueryContextFunc(ctx, sqlText, params...)
}

// QueryContextCalls gets all the calls that were made to QueryContext.
// Check the length with:
//
//	len(mockedDatabaseServer.QueryContextCalls())
func (mock *DatabaseServerMock) QueryContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockQueryContext.RLock()
	calls = mock.calls.QueryContext
	mock.lockQueryContext.RUnlock()
	return calls
}

// QueryRow calls QueryRowFunc.
func (mock *DatabaseServerMock) QueryRow(sqlText string, params ...any) spi.Row {
	if mock.QueryRowFunc == nil {
		panic("DatabaseServerMock.QueryRowFunc: method is nil but DatabaseServer.QueryRow was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryRow.Lock()
	mock.calls.QueryRow = append(mock.calls.QueryRow, callInfo)
	mock.lockQueryRow.Unlock()
	return mock.QueryRowFunc(sqlText, params...)
}

// QueryRowCalls gets all the calls that were made to QueryRow.
// Check the length with:
//
//	len(mockedDatabaseServer.QueryRowCalls())
func (mock *DatabaseServerMock) QueryRowCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockQueryRow.RLock()
	calls = mock.calls.QueryRow
	mock.lockQueryRow.RUnlock()
	return calls
}

// QueryRowContext calls QueryRowContextFunc.
func (mock *DatabaseServerMock) QueryRowContext(ctx context.Context, sqlText string, params ...any) spi.Row {
	if mock.QueryRowContextFunc == nil {
		panic("DatabaseServerMock.QueryRowContextFunc: method is nil but DatabaseServer.QueryRowContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryRowContext.Lock()
	mock.calls.QueryRowContext = append(mock.calls.QueryRowContext, callInfo)
	mock.lockQueryRowContext.Unlock()
	return mock.QueryRowContextFunc(ctx, sqlText, params...)
}

// QueryRowContextCalls gets all the calls that were made to QueryRowContext.
// Check the length with:
//
//	len(mockedDatabaseServer.QueryRowContextCalls())
func (mock *DatabaseServerMock) QueryRowContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockQueryRowContext.RLock()
	calls = mock.calls.QueryRowContext
	mock.lockQueryRowContext.RUnlock()
	return calls
}

// Shutdown calls ShutdownFunc.
func (mock *DatabaseServerMock) Shutdown() error {
	if mock.ShutdownFunc == nil {
		panic("DatabaseServerMock.ShutdownFunc: method is nil but DatabaseServer.Shutdown was just called")
	}
	callInfo := struct {
	}{}
	mock.lockShutdown.Lock()
	mock.calls.Shutdown = append(mock.calls.Shutdown, callInfo)
	mock.lockShutdown.Unlock()
	return mock.ShutdownFunc()
}

// ShutdownCalls gets all the calls that were made to Shutdown.
// Check the length with:
//
//	len(mockedDatabaseServer.ShutdownCalls())
func (mock *DatabaseServerMock) ShutdownCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockShutdown.RLock()
	calls = mock.calls.Shutdown
	mock.lockShutdown.RUnlock()
	return calls
}

// Startup calls StartupFunc.
func (mock *DatabaseServerMock) Startup() error {
	if mock.StartupFunc == nil {
		panic("DatabaseServerMock.StartupFunc: method is nil but DatabaseServer.Startup was just called")
	}
	callInfo := struct {
	}{}
	mock.lockStartup.Lock()
	mock.calls.Startup = append(mock.calls.Startup, callInfo)
	mock.lockStartup.Unlock()
	return mock.StartupFunc()
}

// StartupCalls gets all the calls that were made to Startup.
// Check the length with:
//
//	len(mockedDatabaseServer.StartupCalls())
func (mock *DatabaseServerMock) StartupCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockStartup.RLock()
	calls = mock.calls.Startup
	mock.lockStartup.RUnlock()
	return calls
}

// Ensure, that DatabaseClientMock does implement spi.DatabaseClient.
// If this is not the case, regenerate this file with moq.
var _ spi.DatabaseClient = &DatabaseClientMock{}

// DatabaseClientMock is a mock implementation of spi.DatabaseClient.
//
//	func TestSomethingThatUsesDatabaseClient(t *testing.T) {
//
//		// make and configure a mocked spi.DatabaseClient
//		mockedDatabaseClient := &DatabaseClientMock{
//			AppenderFunc: func(tableName string, opts ...spi.AppendOption) (spi.Appender, error) {
//				panic("mock out the Appender method")
//			},
//			ConnectFunc: func() error {
//				panic("mock out the Connect method")
//			},
//			DisconnectFunc: func()  {
//				panic("mock out the Disconnect method")
//			},
//			ExecFunc: func(sqlText string, params ...any) spi.Result {
//				panic("mock out the Exec method")
//			},
//			ExecContextFunc: func(ctx context.Context, sqlText string, params ...any) spi.Result {
//				panic("mock out the ExecContext method")
//			},
//			QueryFunc: func(sqlText string, params ...any) (spi.Rows, error) {
//				panic("mock out the Query method")
//			},
//			QueryContextFunc: func(ctx context.Context, sqlText string, params ...any) (spi.Rows, error) {
//				panic("mock out the QueryContext method")
//			},
//			QueryRowFunc: func(sqlText string, params ...any) spi.Row {
//				panic("mock out the QueryRow method")
//			},
//			QueryRowContextFunc: func(ctx context.Context, sqlText string, params ...any) spi.Row {
//				panic("mock out the QueryRowContext method")
//			},
//		}
//
//		// use mockedDatabaseClient in code that requires spi.DatabaseClient
//		// and then make assertions.
//
//	}
type DatabaseClientMock struct {
	// AppenderFunc mocks the Appender method.
	AppenderFunc func(tableName string, opts ...spi.AppendOption) (spi.Appender, error)

	// ConnectFunc mocks the Connect method.
	ConnectFunc func() error

	// DisconnectFunc mocks the Disconnect method.
	DisconnectFunc func()

	// ExecFunc mocks the Exec method.
	ExecFunc func(sqlText string, params ...any) spi.Result

	// ExecContextFunc mocks the ExecContext method.
	ExecContextFunc func(ctx context.Context, sqlText string, params ...any) spi.Result

	// QueryFunc mocks the Query method.
	QueryFunc func(sqlText string, params ...any) (spi.Rows, error)

	// QueryContextFunc mocks the QueryContext method.
	QueryContextFunc func(ctx context.Context, sqlText string, params ...any) (spi.Rows, error)

	// QueryRowFunc mocks the QueryRow method.
	QueryRowFunc func(sqlText string, params ...any) spi.Row

	// QueryRowContextFunc mocks the QueryRowContext method.
	QueryRowContextFunc func(ctx context.Context, sqlText string, params ...any) spi.Row

	// calls tracks calls to the methods.
	calls struct {
		// Appender holds details about calls to the Appender method.
		Appender []struct {
			// TableName is the tableName argument value.
			TableName string
			// Opts is the opts argument value.
			Opts []spi.AppendOption
		}
		// Connect holds details about calls to the Connect method.
		Connect []struct {
		}
		// Disconnect holds details about calls to the Disconnect method.
		Disconnect []struct {
		}
		// Exec holds details about calls to the Exec method.
		Exec []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// ExecContext holds details about calls to the ExecContext method.
		ExecContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// Query holds details about calls to the Query method.
		Query []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryContext holds details about calls to the QueryContext method.
		QueryContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryRow holds details about calls to the QueryRow method.
		QueryRow []struct {
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
		// QueryRowContext holds details about calls to the QueryRowContext method.
		QueryRowContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// SqlText is the sqlText argument value.
			SqlText string
			// Params is the params argument value.
			Params []any
		}
	}
	lockAppender        sync.RWMutex
	lockConnect         sync.RWMutex
	lockDisconnect      sync.RWMutex
	lockExec            sync.RWMutex
	lockExecContext     sync.RWMutex
	lockQuery           sync.RWMutex
	lockQueryContext    sync.RWMutex
	lockQueryRow        sync.RWMutex
	lockQueryRowContext sync.RWMutex
}

// Appender calls AppenderFunc.
func (mock *DatabaseClientMock) Appender(tableName string, opts ...spi.AppendOption) (spi.Appender, error) {
	if mock.AppenderFunc == nil {
		panic("DatabaseClientMock.AppenderFunc: method is nil but DatabaseClient.Appender was just called")
	}
	callInfo := struct {
		TableName string
		Opts      []spi.AppendOption
	}{
		TableName: tableName,
		Opts:      opts,
	}
	mock.lockAppender.Lock()
	mock.calls.Appender = append(mock.calls.Appender, callInfo)
	mock.lockAppender.Unlock()
	return mock.AppenderFunc(tableName, opts...)
}

// AppenderCalls gets all the calls that were made to Appender.
// Check the length with:
//
//	len(mockedDatabaseClient.AppenderCalls())
func (mock *DatabaseClientMock) AppenderCalls() []struct {
	TableName string
	Opts      []spi.AppendOption
} {
	var calls []struct {
		TableName string
		Opts      []spi.AppendOption
	}
	mock.lockAppender.RLock()
	calls = mock.calls.Appender
	mock.lockAppender.RUnlock()
	return calls
}

// Connect calls ConnectFunc.
func (mock *DatabaseClientMock) Connect() error {
	if mock.ConnectFunc == nil {
		panic("DatabaseClientMock.ConnectFunc: method is nil but DatabaseClient.Connect was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConnect.Lock()
	mock.calls.Connect = append(mock.calls.Connect, callInfo)
	mock.lockConnect.Unlock()
	return mock.ConnectFunc()
}

// ConnectCalls gets all the calls that were made to Connect.
// Check the length with:
//
//	len(mockedDatabaseClient.ConnectCalls())
func (mock *DatabaseClientMock) ConnectCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConnect.RLock()
	calls = mock.calls.Connect
	mock.lockConnect.RUnlock()
	return calls
}

// Disconnect calls DisconnectFunc.
func (mock *DatabaseClientMock) Disconnect() {
	if mock.DisconnectFunc == nil {
		panic("DatabaseClientMock.DisconnectFunc: method is nil but DatabaseClient.Disconnect was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDisconnect.Lock()
	mock.calls.Disconnect = append(mock.calls.Disconnect, callInfo)
	mock.lockDisconnect.Unlock()
	mock.DisconnectFunc()
}

// DisconnectCalls gets all the calls that were made to Disconnect.
// Check the length with:
//
//	len(mockedDatabaseClient.DisconnectCalls())
func (mock *DatabaseClientMock) DisconnectCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDisconnect.RLock()
	calls = mock.calls.Disconnect
	mock.lockDisconnect.RUnlock()
	return calls
}

// Exec calls ExecFunc.
func (mock *DatabaseClientMock) Exec(sqlText string, params ...any) spi.Result {
	if mock.ExecFunc == nil {
		panic("DatabaseClientMock.ExecFunc: method is nil but DatabaseClient.Exec was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockExec.Lock()
	mock.calls.Exec = append(mock.calls.Exec, callInfo)
	mock.lockExec.Unlock()
	return mock.ExecFunc(sqlText, params...)
}

// ExecCalls gets all the calls that were made to Exec.
// Check the length with:
//
//	len(mockedDatabaseClient.ExecCalls())
func (mock *DatabaseClientMock) ExecCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockExec.RLock()
	calls = mock.calls.Exec
	mock.lockExec.RUnlock()
	return calls
}

// ExecContext calls ExecContextFunc.
func (mock *DatabaseClientMock) ExecContext(ctx context.Context, sqlText string, params ...any) spi.Result {
	if mock.ExecContextFunc == nil {
		panic("DatabaseClientMock.ExecContextFunc: method is nil but DatabaseClient.ExecContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockExecContext.Lock()
	mock.calls.ExecContext = append(mock.calls.ExecContext, callInfo)
	mock.lockExecContext.Unlock()
	return mock.ExecContextFunc(ctx, sqlText, params...)
}

// ExecContextCalls gets all the calls that were made to ExecContext.
// Check the length with:
//
//	len(mockedDatabaseClient.ExecContextCalls())
func (mock *DatabaseClientMock) ExecContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockExecContext.RLock()
	calls = mock.calls.ExecContext
	mock.lockExecContext.RUnlock()
	return calls
}

// Query calls QueryFunc.
func (mock *DatabaseClientMock) Query(sqlText string, params ...any) (spi.Rows, error) {
	if mock.QueryFunc == nil {
		panic("DatabaseClientMock.QueryFunc: method is nil but DatabaseClient.Query was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQuery.Lock()
	mock.calls.Query = append(mock.calls.Query, callInfo)
	mock.lockQuery.Unlock()
	return mock.QueryFunc(sqlText, params...)
}

// QueryCalls gets all the calls that were made to Query.
// Check the length with:
//
//	len(mockedDatabaseClient.QueryCalls())
func (mock *DatabaseClientMock) QueryCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockQuery.RLock()
	calls = mock.calls.Query
	mock.lockQuery.RUnlock()
	return calls
}

// QueryContext calls QueryContextFunc.
func (mock *DatabaseClientMock) QueryContext(ctx context.Context, sqlText string, params ...any) (spi.Rows, error) {
	if mock.QueryContextFunc == nil {
		panic("DatabaseClientMock.QueryContextFunc: method is nil but DatabaseClient.QueryContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryContext.Lock()
	mock.calls.QueryContext = append(mock.calls.QueryContext, callInfo)
	mock.lockQueryContext.Unlock()
	return mock.QueryContextFunc(ctx, sqlText, params...)
}

// QueryContextCalls gets all the calls that were made to QueryContext.
// Check the length with:
//
//	len(mockedDatabaseClient.QueryContextCalls())
func (mock *DatabaseClientMock) QueryContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockQueryContext.RLock()
	calls = mock.calls.QueryContext
	mock.lockQueryContext.RUnlock()
	return calls
}

// QueryRow calls QueryRowFunc.
func (mock *DatabaseClientMock) QueryRow(sqlText string, params ...any) spi.Row {
	if mock.QueryRowFunc == nil {
		panic("DatabaseClientMock.QueryRowFunc: method is nil but DatabaseClient.QueryRow was just called")
	}
	callInfo := struct {
		SqlText string
		Params  []any
	}{
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryRow.Lock()
	mock.calls.QueryRow = append(mock.calls.QueryRow, callInfo)
	mock.lockQueryRow.Unlock()
	return mock.QueryRowFunc(sqlText, params...)
}

// QueryRowCalls gets all the calls that were made to QueryRow.
// Check the length with:
//
//	len(mockedDatabaseClient.QueryRowCalls())
func (mock *DatabaseClientMock) QueryRowCalls() []struct {
	SqlText string
	Params  []any
} {
	var calls []struct {
		SqlText string
		Params  []any
	}
	mock.lockQueryRow.RLock()
	calls = mock.calls.QueryRow
	mock.lockQueryRow.RUnlock()
	return calls
}

// QueryRowContext calls QueryRowContextFunc.
func (mock *DatabaseClientMock) QueryRowContext(ctx context.Context, sqlText string, params ...any) spi.Row {
	if mock.QueryRowContextFunc == nil {
		panic("DatabaseClientMock.QueryRowContextFunc: method is nil but DatabaseClient.QueryRowContext was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}{
		Ctx:     ctx,
		SqlText: sqlText,
		Params:  params,
	}
	mock.lockQueryRowContext.Lock()
	mock.calls.QueryRowContext = append(mock.calls.QueryRowContext, callInfo)
	mock.lockQueryRowContext.Unlock()
	return mock.QueryRowContextFunc(ctx, sqlText, params...)
}

// QueryRowContextCalls gets all the calls that were made to QueryRowContext.
// Check the length with:
//
//	len(mockedDatabaseClient.QueryRowContextCalls())
func (mock *DatabaseClientMock) QueryRowContextCalls() []struct {
	Ctx     context.Context
	SqlText string
	Params  []any
} {
	var calls []struct {
		Ctx     context.Context
		SqlText string
		Params  []any
	}
	mock.lockQueryRowContext.RLock()
	calls = mock.calls.QueryRowContext
	mock.lockQueryRowContext.RUnlock()
	return calls
}

// Ensure, that DatabaseAuthMock does implement spi.DatabaseAuth.
// If this is not the case, regenerate this file with moq.
var _ spi.DatabaseAuth = &DatabaseAuthMock{}

// DatabaseAuthMock is a mock implementation of spi.DatabaseAuth.
//
//	func TestSomethingThatUsesDatabaseAuth(t *testing.T) {
//
//		// make and configure a mocked spi.DatabaseAuth
//		mockedDatabaseAuth := &DatabaseAuthMock{
//			UserAuthFunc: func(user string, password string) (bool, error) {
//				panic("mock out the UserAuth method")
//			},
//		}
//
//		// use mockedDatabaseAuth in code that requires spi.DatabaseAuth
//		// and then make assertions.
//
//	}
type DatabaseAuthMock struct {
	// UserAuthFunc mocks the UserAuth method.
	UserAuthFunc func(user string, password string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// UserAuth holds details about calls to the UserAuth method.
		UserAuth []struct {
			// User is the user argument value.
			User string
			// Password is the password argument value.
			Password string
		}
	}
	lockUserAuth sync.RWMutex
}

// UserAuth calls UserAuthFunc.
func (mock *DatabaseAuthMock) UserAuth(user string, password string) (bool, error) {
	if mock.UserAuthFunc == nil {
		panic("DatabaseAuthMock.UserAuthFunc: method is nil but DatabaseAuth.UserAuth was just called")
	}
	callInfo := struct {
		User     string
		Password string
	}{
		User:     user,
		Password: password,
	}
	mock.lockUserAuth.Lock()
	mock.calls.UserAuth = append(mock.calls.UserAuth, callInfo)
	mock.lockUserAuth.Unlock()
	return mock.UserAuthFunc(user, password)
}

// UserAuthCalls gets all the calls that were made to UserAuth.
// Check the length with:
//
//	len(mockedDatabaseAuth.UserAuthCalls())
func (mock *DatabaseAuthMock) UserAuthCalls() []struct {
	User     string
	Password string
} {
	var calls []struct {
		User     string
		Password string
	}
	mock.lockUserAuth.RLock()
	calls = mock.calls.UserAuth
	mock.lockUserAuth.RUnlock()
	return calls
}

// Ensure, that ResultMock does implement spi.Result.
// If this is not the case, regenerate this file with moq.
var _ spi.Result = &ResultMock{}

// ResultMock is a mock implementation of spi.Result.
//
//	func TestSomethingThatUsesResult(t *testing.T) {
//
//		// make and configure a mocked spi.Result
//		mockedResult := &ResultMock{
//			ErrFunc: func() error {
//				panic("mock out the Err method")
//			},
//			MessageFunc: func() string {
//				panic("mock out the Message method")
//			},
//			RowsAffectedFunc: func() int64 {
//				panic("mock out the RowsAffected method")
//			},
//		}
//
//		// use mockedResult in code that requires spi.Result
//		// and then make assertions.
//
//	}
type ResultMock struct {
	// ErrFunc mocks the Err method.
	ErrFunc func() error

	// MessageFunc mocks the Message method.
	MessageFunc func() string

	// RowsAffectedFunc mocks the RowsAffected method.
	RowsAffectedFunc func() int64

	// calls tracks calls to the methods.
	calls struct {
		// Err holds details about calls to the Err method.
		Err []struct {
		}
		// Message holds details about calls to the Message method.
		Message []struct {
		}
		// RowsAffected holds details about calls to the RowsAffected method.
		RowsAffected []struct {
		}
	}
	lockErr          sync.RWMutex
	lockMessage      sync.RWMutex
	lockRowsAffected sync.RWMutex
}

// Err calls ErrFunc.
func (mock *ResultMock) Err() error {
	if mock.ErrFunc == nil {
		panic("ResultMock.ErrFunc: method is nil but Result.Err was just called")
	}
	callInfo := struct {
	}{}
	mock.lockErr.Lock()
	mock.calls.Err = append(mock.calls.Err, callInfo)
	mock.lockErr.Unlock()
	return mock.ErrFunc()
}

// ErrCalls gets all the calls that were made to Err.
// Check the length with:
//
//	len(mockedResult.ErrCalls())
func (mock *ResultMock) ErrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockErr.RLock()
	calls = mock.calls.Err
	mock.lockErr.RUnlock()
	return calls
}

// Message calls MessageFunc.
func (mock *ResultMock) Message() string {
	if mock.MessageFunc == nil {
		panic("ResultMock.MessageFunc: method is nil but Result.Message was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMessage.Lock()
	mock.calls.Message = append(mock.calls.Message, callInfo)
	mock.lockMessage.Unlock()
	return mock.MessageFunc()
}

// MessageCalls gets all the calls that were made to Message.
// Check the length with:
//
//	len(mockedResult.MessageCalls())
func (mock *ResultMock) MessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMessage.RLock()
	calls = mock.calls.Message
	mock.lockMessage.RUnlock()
	return calls
}

// RowsAffected calls RowsAffectedFunc.
func (mock *ResultMock) RowsAffected() int64 {
	if mock.RowsAffectedFunc == nil {
		panic("ResultMock.RowsAffectedFunc: method is nil but Result.RowsAffected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRowsAffected.Lock()
	mock.calls.RowsAffected = append(mock.calls.RowsAffected, callInfo)
	mock.lockRowsAffected.Unlock()
	return mock.RowsAffectedFunc()
}

// RowsAffectedCalls gets all the calls that were made to RowsAffected.
// Check the length with:
//
//	len(mockedResult.RowsAffectedCalls())
func (mock *ResultMock) RowsAffectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRowsAffected.RLock()
	calls = mock.calls.RowsAffected
	mock.lockRowsAffected.RUnlock()
	return calls
}

// Ensure, that RowsMock does implement spi.Rows.
// If this is not the case, regenerate this file with moq.
var _ spi.Rows = &RowsMock{}

// RowsMock is a mock implementation of spi.Rows.
//
//	func TestSomethingThatUsesRows(t *testing.T) {
//
//		// make and configure a mocked spi.Rows
//		mockedRows := &RowsMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			ColumnsFunc: func() (spi.Columns, error) {
//				panic("mock out the Columns method")
//			},
//			IsFetchableFunc: func() bool {
//				panic("mock out the IsFetchable method")
//			},
//			MessageFunc: func() string {
//				panic("mock out the Message method")
//			},
//			NextFunc: func() bool {
//				panic("mock out the Next method")
//			},
//			RowsAffectedFunc: func() int64 {
//				panic("mock out the RowsAffected method")
//			},
//			ScanFunc: func(cols ...any) error {
//				panic("mock out the Scan method")
//			},
//		}
//
//		// use mockedRows in code that requires spi.Rows
//		// and then make assertions.
//
//	}
type RowsMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// ColumnsFunc mocks the Columns method.
	ColumnsFunc func() (spi.Columns, error)

	// IsFetchableFunc mocks the IsFetchable method.
	IsFetchableFunc func() bool

	// MessageFunc mocks the Message method.
	MessageFunc func() string

	// NextFunc mocks the Next method.
	NextFunc func() bool

	// RowsAffectedFunc mocks the RowsAffected method.
	RowsAffectedFunc func() int64

	// ScanFunc mocks the Scan method.
	ScanFunc func(cols ...any) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Columns holds details about calls to the Columns method.
		Columns []struct {
		}
		// IsFetchable holds details about calls to the IsFetchable method.
		IsFetchable []struct {
		}
		// Message holds details about calls to the Message method.
		Message []struct {
		}
		// Next holds details about calls to the Next method.
		Next []struct {
		}
		// RowsAffected holds details about calls to the RowsAffected method.
		RowsAffected []struct {
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Cols is the cols argument value.
			Cols []any
		}
	}
	lockClose        sync.RWMutex
	lockColumns      sync.RWMutex
	lockIsFetchable  sync.RWMutex
	lockMessage      sync.RWMutex
	lockNext         sync.RWMutex
	lockRowsAffected sync.RWMutex
	lockScan         sync.RWMutex
}

// Close calls CloseFunc.
func (mock *RowsMock) Close() error {
	if mock.CloseFunc == nil {
		panic("RowsMock.CloseFunc: method is nil but Rows.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedRows.CloseCalls())
func (mock *RowsMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Columns calls ColumnsFunc.
func (mock *RowsMock) Columns() (spi.Columns, error) {
	if mock.ColumnsFunc == nil {
		panic("RowsMock.ColumnsFunc: method is nil but Rows.Columns was just called")
	}
	callInfo := struct {
	}{}
	mock.lockColumns.Lock()
	mock.calls.Columns = append(mock.calls.Columns, callInfo)
	mock.lockColumns.Unlock()
	return mock.ColumnsFunc()
}

// ColumnsCalls gets all the calls that were made to Columns.
// Check the length with:
//
//	len(mockedRows.ColumnsCalls())
func (mock *RowsMock) ColumnsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockColumns.RLock()
	calls = mock.calls.Columns
	mock.lockColumns.RUnlock()
	return calls
}

// IsFetchable calls IsFetchableFunc.
func (mock *RowsMock) IsFetchable() bool {
	if mock.IsFetchableFunc == nil {
		panic("RowsMock.IsFetchableFunc: method is nil but Rows.IsFetchable was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIsFetchable.Lock()
	mock.calls.IsFetchable = append(mock.calls.IsFetchable, callInfo)
	mock.lockIsFetchable.Unlock()
	return mock.IsFetchableFunc()
}

// IsFetchableCalls gets all the calls that were made to IsFetchable.
// Check the length with:
//
//	len(mockedRows.IsFetchableCalls())
func (mock *RowsMock) IsFetchableCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIsFetchable.RLock()
	calls = mock.calls.IsFetchable
	mock.lockIsFetchable.RUnlock()
	return calls
}

// Message calls MessageFunc.
func (mock *RowsMock) Message() string {
	if mock.MessageFunc == nil {
		panic("RowsMock.MessageFunc: method is nil but Rows.Message was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMessage.Lock()
	mock.calls.Message = append(mock.calls.Message, callInfo)
	mock.lockMessage.Unlock()
	return mock.MessageFunc()
}

// MessageCalls gets all the calls that were made to Message.
// Check the length with:
//
//	len(mockedRows.MessageCalls())
func (mock *RowsMock) MessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMessage.RLock()
	calls = mock.calls.Message
	mock.lockMessage.RUnlock()
	return calls
}

// Next calls NextFunc.
func (mock *RowsMock) Next() bool {
	if mock.NextFunc == nil {
		panic("RowsMock.NextFunc: method is nil but Rows.Next was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNext.Lock()
	mock.calls.Next = append(mock.calls.Next, callInfo)
	mock.lockNext.Unlock()
	return mock.NextFunc()
}

// NextCalls gets all the calls that were made to Next.
// Check the length with:
//
//	len(mockedRows.NextCalls())
func (mock *RowsMock) NextCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNext.RLock()
	calls = mock.calls.Next
	mock.lockNext.RUnlock()
	return calls
}

// RowsAffected calls RowsAffectedFunc.
func (mock *RowsMock) RowsAffected() int64 {
	if mock.RowsAffectedFunc == nil {
		panic("RowsMock.RowsAffectedFunc: method is nil but Rows.RowsAffected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRowsAffected.Lock()
	mock.calls.RowsAffected = append(mock.calls.RowsAffected, callInfo)
	mock.lockRowsAffected.Unlock()
	return mock.RowsAffectedFunc()
}

// RowsAffectedCalls gets all the calls that were made to RowsAffected.
// Check the length with:
//
//	len(mockedRows.RowsAffectedCalls())
func (mock *RowsMock) RowsAffectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRowsAffected.RLock()
	calls = mock.calls.RowsAffected
	mock.lockRowsAffected.RUnlock()
	return calls
}

// Scan calls ScanFunc.
func (mock *RowsMock) Scan(cols ...any) error {
	if mock.ScanFunc == nil {
		panic("RowsMock.ScanFunc: method is nil but Rows.Scan was just called")
	}
	callInfo := struct {
		Cols []any
	}{
		Cols: cols,
	}
	mock.lockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	mock.lockScan.Unlock()
	return mock.ScanFunc(cols...)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//
//	len(mockedRows.ScanCalls())
func (mock *RowsMock) ScanCalls() []struct {
	Cols []any
} {
	var calls []struct {
		Cols []any
	}
	mock.lockScan.RLock()
	calls = mock.calls.Scan
	mock.lockScan.RUnlock()
	return calls
}

// Ensure, that RowMock does implement spi.Row.
// If this is not the case, regenerate this file with moq.
var _ spi.Row = &RowMock{}

// RowMock is a mock implementation of spi.Row.
//
//	func TestSomethingThatUsesRow(t *testing.T) {
//
//		// make and configure a mocked spi.Row
//		mockedRow := &RowMock{
//			ErrFunc: func() error {
//				panic("mock out the Err method")
//			},
//			MessageFunc: func() string {
//				panic("mock out the Message method")
//			},
//			RowsAffectedFunc: func() int64 {
//				panic("mock out the RowsAffected method")
//			},
//			ScanFunc: func(cols ...any) error {
//				panic("mock out the Scan method")
//			},
//			SuccessFunc: func() bool {
//				panic("mock out the Success method")
//			},
//			ValuesFunc: func() []any {
//				panic("mock out the Values method")
//			},
//		}
//
//		// use mockedRow in code that requires spi.Row
//		// and then make assertions.
//
//	}
type RowMock struct {
	// ErrFunc mocks the Err method.
	ErrFunc func() error

	// MessageFunc mocks the Message method.
	MessageFunc func() string

	// RowsAffectedFunc mocks the RowsAffected method.
	RowsAffectedFunc func() int64

	// ScanFunc mocks the Scan method.
	ScanFunc func(cols ...any) error

	// SuccessFunc mocks the Success method.
	SuccessFunc func() bool

	// ValuesFunc mocks the Values method.
	ValuesFunc func() []any

	// calls tracks calls to the methods.
	calls struct {
		// Err holds details about calls to the Err method.
		Err []struct {
		}
		// Message holds details about calls to the Message method.
		Message []struct {
		}
		// RowsAffected holds details about calls to the RowsAffected method.
		RowsAffected []struct {
		}
		// Scan holds details about calls to the Scan method.
		Scan []struct {
			// Cols is the cols argument value.
			Cols []any
		}
		// Success holds details about calls to the Success method.
		Success []struct {
		}
		// Values holds details about calls to the Values method.
		Values []struct {
		}
	}
	lockErr          sync.RWMutex
	lockMessage      sync.RWMutex
	lockRowsAffected sync.RWMutex
	lockScan         sync.RWMutex
	lockSuccess      sync.RWMutex
	lockValues       sync.RWMutex
}

// Err calls ErrFunc.
func (mock *RowMock) Err() error {
	if mock.ErrFunc == nil {
		panic("RowMock.ErrFunc: method is nil but Row.Err was just called")
	}
	callInfo := struct {
	}{}
	mock.lockErr.Lock()
	mock.calls.Err = append(mock.calls.Err, callInfo)
	mock.lockErr.Unlock()
	return mock.ErrFunc()
}

// ErrCalls gets all the calls that were made to Err.
// Check the length with:
//
//	len(mockedRow.ErrCalls())
func (mock *RowMock) ErrCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockErr.RLock()
	calls = mock.calls.Err
	mock.lockErr.RUnlock()
	return calls
}

// Message calls MessageFunc.
func (mock *RowMock) Message() string {
	if mock.MessageFunc == nil {
		panic("RowMock.MessageFunc: method is nil but Row.Message was just called")
	}
	callInfo := struct {
	}{}
	mock.lockMessage.Lock()
	mock.calls.Message = append(mock.calls.Message, callInfo)
	mock.lockMessage.Unlock()
	return mock.MessageFunc()
}

// MessageCalls gets all the calls that were made to Message.
// Check the length with:
//
//	len(mockedRow.MessageCalls())
func (mock *RowMock) MessageCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockMessage.RLock()
	calls = mock.calls.Message
	mock.lockMessage.RUnlock()
	return calls
}

// RowsAffected calls RowsAffectedFunc.
func (mock *RowMock) RowsAffected() int64 {
	if mock.RowsAffectedFunc == nil {
		panic("RowMock.RowsAffectedFunc: method is nil but Row.RowsAffected was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRowsAffected.Lock()
	mock.calls.RowsAffected = append(mock.calls.RowsAffected, callInfo)
	mock.lockRowsAffected.Unlock()
	return mock.RowsAffectedFunc()
}

// RowsAffectedCalls gets all the calls that were made to RowsAffected.
// Check the length with:
//
//	len(mockedRow.RowsAffectedCalls())
func (mock *RowMock) RowsAffectedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRowsAffected.RLock()
	calls = mock.calls.RowsAffected
	mock.lockRowsAffected.RUnlock()
	return calls
}

// Scan calls ScanFunc.
func (mock *RowMock) Scan(cols ...any) error {
	if mock.ScanFunc == nil {
		panic("RowMock.ScanFunc: method is nil but Row.Scan was just called")
	}
	callInfo := struct {
		Cols []any
	}{
		Cols: cols,
	}
	mock.lockScan.Lock()
	mock.calls.Scan = append(mock.calls.Scan, callInfo)
	mock.lockScan.Unlock()
	return mock.ScanFunc(cols...)
}

// ScanCalls gets all the calls that were made to Scan.
// Check the length with:
//
//	len(mockedRow.ScanCalls())
func (mock *RowMock) ScanCalls() []struct {
	Cols []any
} {
	var calls []struct {
		Cols []any
	}
	mock.lockScan.RLock()
	calls = mock.calls.Scan
	mock.lockScan.RUnlock()
	return calls
}

// Success calls SuccessFunc.
func (mock *RowMock) Success() bool {
	if mock.SuccessFunc == nil {
		panic("RowMock.SuccessFunc: method is nil but Row.Success was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSuccess.Lock()
	mock.calls.Success = append(mock.calls.Success, callInfo)
	mock.lockSuccess.Unlock()
	return mock.SuccessFunc()
}

// SuccessCalls gets all the calls that were made to Success.
// Check the length with:
//
//	len(mockedRow.SuccessCalls())
func (mock *RowMock) SuccessCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSuccess.RLock()
	calls = mock.calls.Success
	mock.lockSuccess.RUnlock()
	return calls
}

// Values calls ValuesFunc.
func (mock *RowMock) Values() []any {
	if mock.ValuesFunc == nil {
		panic("RowMock.ValuesFunc: method is nil but Row.Values was just called")
	}
	callInfo := struct {
	}{}
	mock.lockValues.Lock()
	mock.calls.Values = append(mock.calls.Values, callInfo)
	mock.lockValues.Unlock()
	return mock.ValuesFunc()
}

// ValuesCalls gets all the calls that were made to Values.
// Check the length with:
//
//	len(mockedRow.ValuesCalls())
func (mock *RowMock) ValuesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockValues.RLock()
	calls = mock.calls.Values
	mock.lockValues.RUnlock()
	return calls
}

// Ensure, that AppenderMock does implement spi.Appender.
// If this is not the case, regenerate this file with moq.
var _ spi.Appender = &AppenderMock{}

// AppenderMock is a mock implementation of spi.Appender.
//
//	func TestSomethingThatUsesAppender(t *testing.T) {
//
//		// make and configure a mocked spi.Appender
//		mockedAppender := &AppenderMock{
//			AppendFunc: func(values ...any) error {
//				panic("mock out the Append method")
//			},
//			AppendWithTimestampFunc: func(ts time.Time, values ...any) error {
//				panic("mock out the AppendWithTimestamp method")
//			},
//			CloseFunc: func() (int64, int64, error) {
//				panic("mock out the Close method")
//			},
//			ColumnsFunc: func() (spi.Columns, error) {
//				panic("mock out the Columns method")
//			},
//			TableNameFunc: func() string {
//				panic("mock out the TableName method")
//			},
//			TableTypeFunc: func() spi.TableType {
//				panic("mock out the TableType method")
//			},
//		}
//
//		// use mockedAppender in code that requires spi.Appender
//		// and then make assertions.
//
//	}
type AppenderMock struct {
	// AppendFunc mocks the Append method.
	AppendFunc func(values ...any) error

	// AppendWithTimestampFunc mocks the AppendWithTimestamp method.
	AppendWithTimestampFunc func(ts time.Time, values ...any) error

	// CloseFunc mocks the Close method.
	CloseFunc func() (int64, int64, error)

	// ColumnsFunc mocks the Columns method.
	ColumnsFunc func() (spi.Columns, error)

	// TableNameFunc mocks the TableName method.
	TableNameFunc func() string

	// TableTypeFunc mocks the TableType method.
	TableTypeFunc func() spi.TableType

	// calls tracks calls to the methods.
	calls struct {
		// Append holds details about calls to the Append method.
		Append []struct {
			// Values is the values argument value.
			Values []any
		}
		// AppendWithTimestamp holds details about calls to the AppendWithTimestamp method.
		AppendWithTimestamp []struct {
			// Ts is the ts argument value.
			Ts time.Time
			// Values is the values argument value.
			Values []any
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Columns holds details about calls to the Columns method.
		Columns []struct {
		}
		// TableName holds details about calls to the TableName method.
		TableName []struct {
		}
		// TableType holds details about calls to the TableType method.
		TableType []struct {
		}
	}
	lockAppend              sync.RWMutex
	lockAppendWithTimestamp sync.RWMutex
	lockClose               sync.RWMutex
	lockColumns             sync.RWMutex
	lockTableName           sync.RWMutex
	lockTableType           sync.RWMutex
}

// Append calls AppendFunc.
func (mock *AppenderMock) Append(values ...any) error {
	if mock.AppendFunc == nil {
		panic("AppenderMock.AppendFunc: method is nil but Appender.Append was just called")
	}
	callInfo := struct {
		Values []any
	}{
		Values: values,
	}
	mock.lockAppend.Lock()
	mock.calls.Append = append(mock.calls.Append, callInfo)
	mock.lockAppend.Unlock()
	return mock.AppendFunc(values...)
}

// AppendCalls gets all the calls that were made to Append.
// Check the length with:
//
//	len(mockedAppender.AppendCalls())
func (mock *AppenderMock) AppendCalls() []struct {
	Values []any
} {
	var calls []struct {
		Values []any
	}
	mock.lockAppend.RLock()
	calls = mock.calls.Append
	mock.lockAppend.RUnlock()
	return calls
}

// AppendWithTimestamp calls AppendWithTimestampFunc.
func (mock *AppenderMock) AppendWithTimestamp(ts time.Time, values ...any) error {
	if mock.AppendWithTimestampFunc == nil {
		panic("AppenderMock.AppendWithTimestampFunc: method is nil but Appender.AppendWithTimestamp was just called")
	}
	callInfo := struct {
		Ts     time.Time
		Values []any
	}{
		Ts:     ts,
		Values: values,
	}
	mock.lockAppendWithTimestamp.Lock()
	mock.calls.AppendWithTimestamp = append(mock.calls.AppendWithTimestamp, callInfo)
	mock.lockAppendWithTimestamp.Unlock()
	return mock.AppendWithTimestampFunc(ts, values...)
}

// AppendWithTimestampCalls gets all the calls that were made to AppendWithTimestamp.
// Check the length with:
//
//	len(mockedAppender.AppendWithTimestampCalls())
func (mock *AppenderMock) AppendWithTimestampCalls() []struct {
	Ts     time.Time
	Values []any
} {
	var calls []struct {
		Ts     time.Time
		Values []any
	}
	mock.lockAppendWithTimestamp.RLock()
	calls = mock.calls.AppendWithTimestamp
	mock.lockAppendWithTimestamp.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *AppenderMock) Close() (int64, int64, error) {
	if mock.CloseFunc == nil {
		panic("AppenderMock.CloseFunc: method is nil but Appender.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedAppender.CloseCalls())
func (mock *AppenderMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Columns calls ColumnsFunc.
func (mock *AppenderMock) Columns() (spi.Columns, error) {
	if mock.ColumnsFunc == nil {
		panic("AppenderMock.ColumnsFunc: method is nil but Appender.Columns was just called")
	}
	callInfo := struct {
	}{}
	mock.lockColumns.Lock()
	mock.calls.Columns = append(mock.calls.Columns, callInfo)
	mock.lockColumns.Unlock()
	return mock.ColumnsFunc()
}

// ColumnsCalls gets all the calls that were made to Columns.
// Check the length with:
//
//	len(mockedAppender.ColumnsCalls())
func (mock *AppenderMock) ColumnsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockColumns.RLock()
	calls = mock.calls.Columns
	mock.lockColumns.RUnlock()
	return calls
}

// TableName calls TableNameFunc.
func (mock *AppenderMock) TableName() string {
	if mock.TableNameFunc == nil {
		panic("AppenderMock.TableNameFunc: method is nil but Appender.TableName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTableName.Lock()
	mock.calls.TableName = append(mock.calls.TableName, callInfo)
	mock.lockTableName.Unlock()
	return mock.TableNameFunc()
}

// TableNameCalls gets all the calls that were made to TableName.
// Check the length with:
//
//	len(mockedAppender.TableNameCalls())
func (mock *AppenderMock) TableNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTableName.RLock()
	calls = mock.calls.TableName
	mock.lockTableName.RUnlock()
	return calls
}

// TableType calls TableTypeFunc.
func (mock *AppenderMock) TableType() spi.TableType {
	if mock.TableTypeFunc == nil {
		panic("AppenderMock.TableTypeFunc: method is nil but Appender.TableType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTableType.Lock()
	mock.calls.TableType = append(mock.calls.TableType, callInfo)
	mock.lockTableType.Unlock()
	return mock.TableTypeFunc()
}

// TableTypeCalls gets all the calls that were made to TableType.
// Check the length with:
//
//	len(mockedAppender.TableTypeCalls())
func (mock *AppenderMock) TableTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTableType.RLock()
	calls = mock.calls.TableType
	mock.lockTableType.RUnlock()
	return calls
}
